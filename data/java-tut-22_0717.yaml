- en: Connecting with DataSource Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DataSource对象进行连接
- en: 原文：[https://docs.oracle.com/javase/tutorial/jdbc/basics/sqldatasources.html](https://docs.oracle.com/javase/tutorial/jdbc/basics/sqldatasources.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.oracle.com/javase/tutorial/jdbc/basics/sqldatasources.html](https://docs.oracle.com/javase/tutorial/jdbc/basics/sqldatasources.html)
- en: This section covers `DataSource` objects, which are the preferred means of getting
    a connection to a data source. In addition to their other advantages, which will
    be explained later, `DataSource` objects can provide connection pooling and distributed
    transactions. This functionality is essential for enterprise database computing.
    In particular, it is integral to Enterprise JavaBeans (EJB) technology.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了`DataSource`对象，这是获取与数据源连接的首选方法。除了其他优点，稍后将解释的优点之外，`DataSource`对象还可以提供连接池和分布式事务。这种功能对企业数据库计算至关重要。特别是，它对企业JavaBeans（EJB）技术至关重要。
- en: This section shows you how to get a connection using the `DataSource` interface
    and how to use distributed transactions and connection pooling. Both of these
    involve very few code changes in your JDBC application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您展示如何使用`DataSource`接口获取连接以及如何使用分布式事务和连接池。这两者在您的JDBC应用程序中都涉及非常少的代码更改。
- en: The work performed to deploy the classes that make these operations possible,
    which a system administrator usually does with a tool (such as Apache Tomcat or
    Oracle WebLogic Server), varies with the type of `DataSource` object that is being
    deployed. As a result, most of this section is devoted to showing how a system
    administrator sets up the environment so that programmers can use a `DataSource`
    object to get connections.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 部署执行这些操作的类所需的工作，通常由系统管理员使用工具（如Apache Tomcat或Oracle WebLogic Server）完成，取决于部署的`DataSource`对象的类型。因此，本节大部分内容都致力于展示系统管理员如何设置环境，以便程序员可以使用`DataSource`对象获取连接。
- en: 'The following topics are covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的主题包括：
- en: '[Using DataSource Objects to Get Connections](#datasource_connection)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用DataSource对象获取连接](#datasource_connection)'
- en: '[Deploying Basic DataSource Objects](#deploy_datasource)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[部署基本的DataSource对象](#deploy_datasource)'
- en: '[Deploying Other DataSource Implementations](#datasource_implementation)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[部署其他DataSource实现](#datasource_implementation)'
- en: '[Getting and Using Pooled Connections](#pooled_connection)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[获取和使用池化连接](#pooled_connection)'
- en: '[Deploying Distributed Transactions](#deployment_distributed_transactions)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[部署分布式事务](#deployment_distributed_transactions)'
- en: '[Using Connections for Distributed Transactions](#using_connections_distributed_transactions)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用连接进行分布式事务](#using_connections_distributed_transactions)'
- en: Using DataSource Objects to Get a Connection
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DataSource对象获取连接
- en: In [Establishing a Connection](connecting.html), you learned how to get a connection
    using the `DriverManager` class. This section shows you how to use a `DataSource`
    object to get a connection to your data source, which is the preferred way.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[建立连接](connecting.html)中，您学习了如何使用`DriverManager`类获取连接。本节将向您展示如何使用`DataSource`对象获取与数据源的连接，这是首选方法。
- en: 'Objects instantiated by classes that implement the `DataSource` represent a
    particular DBMS or some other data source, such as a file. A `DataSource` object
    represents a particular DBMS or some other data source, such as a file. If a company
    uses more than one data source, it will deploy a separate `DataSource` object
    for each of them. The `DataSource` interface is implemented by a driver vendor.
    It can be implemented in three different ways:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由实现`DataSource`类的类实例化的对象代表特定的DBMS或其他数据源，比如文件。`DataSource`对象代表特定的DBMS或其他数据源，比如文件。如果一个公司使用多个数据源，它将为每个数据源部署一个单独的`DataSource`对象。`DataSource`接口由驱动程序供应商实现。它可以以三种不同的方式实现：
- en: A basic `DataSource` implementation produces standard `Connection` objects that
    are not pooled or used in a distributed transaction.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的`DataSource`实现会生成标准的未池化或未用于分布式事务的`Connection`对象。
- en: A `DataSource` implementation that supports connection pooling produces `Connection`
    objects that participate in connection pooling, that is, connections that can
    be recycled.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持连接池的`DataSource`实现会生成参与连接池的`Connection`对象，即可以被回收的连接。
- en: A `DataSource` implementation that supports distributed transactions produces
    `Connection` objects that can be used in a distributed transaction, that is, a
    transaction that accesses two or more DBMS servers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持分布式事务的`DataSource`实现会生成可用于分布式事务的`Connection`对象，即访问两个或多个DBMS服务器的事务。
- en: A JDBC driver should include at least a basic `DataSource` implementation. For
    example, the Java DB JDBC driver includes the implementation `org.apache.derby.jdbc.ClientDataSource`
    and for MySQL, `com.mysql.jdbc.jdbc2.optional.MysqlDataSource`. If your client
    runs on Java 8 compact profile 2, then the Java DB JDBC driver is `org.apache.derby.jdbc.BasicClientDataSource40`.
    The sample for this tutorial requires compact profile 3 or greater.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC驱动程序应至少包含基本的`DataSource`实现。例如，Java DB JDBC驱动程序包括`org.apache.derby.jdbc.ClientDataSource`的实现，而对于MySQL，则是`com.mysql.jdbc.jdbc2.optional.MysqlDataSource`。如果您的客户端在Java
    8紧凑配置文件2上运行，则Java DB JDBC驱动程序是`org.apache.derby.jdbc.BasicClientDataSource40`。本教程的示例需要紧凑配置文件3或更高版本。
- en: A `DataSource` class that supports distributed transactions typically also implements
    support for connection pooling. For example, a `DataSource` class provided by
    an EJB vendor almost always supports both connection pooling and distributed transactions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 支持分布式事务的`DataSource`类通常也实现了对连接池的支持。例如，由EJB供应商提供的`DataSource`类几乎总是支持连接池和分布式事务。
- en: Suppose that the owner of the thriving chain of The Coffee Break shops, from
    the previous examples, has decided to expand further by selling coffee over the
    Internet. With the large amount of online business expected, the owner will definitely
    need connection pooling. Opening and closing connections involves a great deal
    of overhead, and the owner anticipates that this online ordering system will necessitate
    a sizable number of queries and updates. With connection pooling, a pool of connections
    can be used over and over again, avoiding the expense of creating a new connection
    for every database access. In addition, the owner now has a second DBMS that contains
    data for the recently acquired coffee roasting company. This means that the owner
    will want to be able to write distributed transactions that use both the old DBMS
    server and the new one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面示例中茁壮成长的The Coffee Break连锁店的所有者已决定通过互联网进一步扩展销售咖啡。随着预期的大量在线业务，所有者肯定需要连接池。打开和关闭连接涉及大量开销，所有者预计这个在线订购系统将需要大量的查询和更新。通过连接池，一组连接可以一遍又一遍地使用，避免为每次数据库访问创建新连接的开销。此外，所有者现在有第二个包含最近收购的咖啡烘焙公司数据的DBMS。这意味着所有者希望能够编写使用旧DBMS服务器和新DBMS服务器的分布式事务。
- en: The chain owner has reconfigured the computer system to serve the new, larger
    customer base. The owner has purchased the most recent JDBC driver and an EJB
    application server that works with it to be able to use distributed transactions
    and get the increased performance that comes with connection pooling. Many JDBC
    drivers are available that are compatible with the recently purchased EJB server.
    The owner now has a three-tier architecture, with a new EJB application server
    and JDBC driver in the middle tier and the two DBMS servers as the third tier.
    Client computers making requests are the first tier.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 链店所有者已重新配置计算机系统以服务新的、更大的客户群。所有者已购买最新的JDBC驱动程序和与之配套的EJB应用服务器，以便使用分布式事务并获得连接池带来的性能提升。许多与最近购买的EJB服务器兼容的JDBC驱动程序可用。现在，所有者拥有三层架构，中间层有一个新的EJB应用服务器和JDBC驱动程序，第三层是两个DBMS服务器。发出请求的客户端计算机是第一层。
- en: Deploying Basic DataSource Objects
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署基本的DataSource对象
- en: 'The system administrator needs to deploy `DataSource` objects so that The Coffee
    Break''s programming team can start using them. Deploying a `DataSource` object
    consists of three tasks:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员需要部署`DataSource`对象，以便The Coffee Break的编程团队可以开始使用它们。部署`DataSource`对象包括三个任务：
- en: Creating an instance of the `DataSource` class
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`DataSource`类的实例
- en: Setting its properties
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其属性
- en: Registering it with a naming service that uses the Java Naming and Directory
    Interface (JNDI) API
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用使用Java命名和目录接口（JNDI）API的命名服务进行注册
- en: First, consider the most basic case, which is to use a basic implementation
    of the `DataSource` interface, that is, one that does not support connection pooling
    or distributed transactions. In this case there is only one `DataSource` object
    that needs to be deployed. A basic implementation of `DataSource` produces the
    same kind of connections that the `DriverManager` class produces.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑最基本的情况，即使用`DataSource`接口的基本实现，即不支持连接池或分布式事务的实现。在这种情况下，只需要部署一个`DataSource`对象。`DataSource`的基本实现产生与`DriverManager`类产生的相同类型的连接。
- en: Creating Instance of DataSource Class and Setting its Properties
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建DataSource类的实例并设置其属性
- en: 'Suppose a company that wants only a basic implementation of `DataSource` has
    bought a driver from the JDBC vendor DB Access, Inc. This driver includes the
    class `com.dbaccess.BasicDataSource` that implements the `DataSource` interface.
    The following code excerpt creates an instance of the class `BasicDataSource`
    and sets its properties. After the instance of `BasicDataSource` is deployed,
    a programmer can call the method `DataSource.getConnection` to get a connection
    to the company''s database, `CUSTOMER_ACCOUNTS`. First, the system administrator
    creates the `BasicDataSource` object `*ds*` using the default constructor. The
    system administrator then sets three properties. Note that the following code
    is typically be executed by a deployment tool:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '假设一家只想要一个基本的`DataSource`实现的公司从JDBC供应商DB Access, Inc购买了一个驱动程序。该驱动程序包括实现`DataSource`接口的类`com.dbaccess.BasicDataSource`。以下代码摘录创建`BasicDataSource`类的实例并设置其属性。部署`BasicDataSource`实例后，程序员可以调用`DataSource.getConnection`方法获取连接到公司数据库`CUSTOMER_ACCOUNTS`。首先，系统管理员使用默认构造函数创建`BasicDataSource`对象`*ds`。然后，系统管理员设置三个属性。请注意，以下代码通常由部署工具执行： '
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The variable `*ds*` now represents the database `CUSTOMER_ACCOUNTS` installed
    on the server. Any connection produced by the `BasicDataSource` object `*ds*`
    will be a connection to the database `CUSTOMER_ACCOUNTS`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`*ds*`现在代表安装在服务器上的数据库`CUSTOMER_ACCOUNTS`。`*ds*`对象生成的任何连接都将是到数据库`CUSTOMER_ACCOUNTS`的连接。
- en: Registering DataSource Object with Naming Service That Uses JNDI API
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用使用JNDI API的命名服务注册DataSource对象
- en: 'With the properties set, the system administrator can register the `BasicDataSource`
    object with a JNDI (Java Naming and Directory Interface) naming service. The particular
    naming service that is used is usually determined by a system property, which
    is not shown here. The following code excerpt registers the `BasicDataSource`
    object and binds it with the logical name `jdbc/billingDB`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性后，系统管理员可以将`BasicDataSource`对象注册到JNDI（Java命名和目录接口）命名服务中。通常使用的特定命名服务通常由系统属性确定，这里没有显示。以下代码摘录注册`BasicDataSource`对象并将其绑定到逻辑名称`jdbc/billingDB`：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code uses the JNDI API. The first line creates an `InitialContext` object,
    which serves as the starting point for a name, similar to root directory in a
    file system. The second line associates, or binds, the `BasicDataSource` object
    `*ds*` to the logical name `jdbc/billingDB`. In the next code excerpt, you give
    the naming service this logical name, and it returns the `BasicDataSource` object.
    The logical name can be any string. In this case, the company decided to use the
    name `billingDB` as the logical name for the `CUSTOMER_ACCOUNTS` database.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用JNDI API。第一行创建一个`InitialContext`对象，它类似于文件系统中的根目录的起始点。第二行将`BasicDataSource`对象`*ds*`与逻辑名称`jdbc/billingDB`关联或绑定。在下一个代码摘录中，您将向命名服务提供此逻辑名称，它将返回`BasicDataSource`对象。逻辑名称可以是任何字符串。在这种情况下，公司决定使用名称`billingDB`作为`CUSTOMER_ACCOUNTS`数据库的逻辑名称。
- en: In the previous example, `jdbc` is a subcontext under the initial context, just
    as a directory under the root directory is a subdirectory. The name `jdbc/billingDB`
    is like a path name, where the last item in the path is analogous to a file name.
    In this case, `billingDB` is the logical name that is given to the `BasicDataSource`
    object `*ds*`. The subcontext `jdbc` is reserved for logical names to be bound
    to `DataSource` objects, so `jdbc` will always be the first part of a logical
    name for a data source.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`jdbc`是初始上下文下的一个子上下文，就像根目录下的目录是子目录一样。名称`jdbc/billingDB`类似于路径名，其中路径中的最后一项类似于文件名。在这种情况下，`billingDB`是赋予`BasicDataSource`对象`*ds*`的逻辑名称。子上下文`jdbc`保留用于绑定到`DataSource`对象的逻辑名称，因此`jdbc`将始终是数据源逻辑名称的第一部分。
- en: Using Deployed DataSource Object
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用部署的DataSource对象
- en: After a basic `DataSource` implementation is deployed by a system administrator,
    it is ready for a programmer to use. This means that a programmer can give the
    logical data source name that was bound to an instance of a `DataSource` class,
    and the JNDI naming service will return an instance of that `DataSource` class.
    The method `getConnection` can then be called on that `DataSource` object to get
    a connection to the data source it represents. For example, a programmer might
    write the following two lines of code to get a `DataSource` object that produces
    a connection to the database `CUSTOMER_ACCOUNTS`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员部署了基本的`DataSource`实现后，程序员就可以开始使用了。这意味着程序员可以提供绑定到`DataSource`类实例的逻辑数据源名称，JNDI命名服务将返回该`DataSource`类的实例。然后可以在该`DataSource`对象上调用`getConnection`方法，以获取连接到其表示的数据源的连接。例如，程序员可能会编写以下两行代码来获取一个产生与数据库`CUSTOMER_ACCOUNTS`连接的`DataSource`对象。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line of code gets an initial context as the starting point for retrieving
    a `DataSource` object. When you supply the logical name `jdbc/billingDB` to the
    method `lookup`, the method returns the `DataSource` object that the system administrator
    bound to `jdbc/billingDB` at deployment time. Because the return value of the
    method `lookup` is a Java `Object`, we must cast it to the more specific `DataSource`
    type before assigning it to the variable `*ds*`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码获取一个初始上下文作为检索`DataSource`对象的起点。当您向`lookup`方法提供逻辑名称`jdbc/billingDB`时，该方法将返回系统管理员在部署时绑定到`jdbc/billingDB`的`DataSource`对象。因为`lookup`方法的返回值是一个Java
    `Object`，我们必须将其转换为更具体的`DataSource`类型，然后将其赋给变量`*ds*`。
- en: The variable `*ds*` is an instance of the class `com.dbaccess.BasicDataSource`
    that implements the `DataSource` interface. Calling the method `*ds*.getConnection`
    produces a connection to the `CUSTOMER_ACCOUNTS` database.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`*ds*`是实现`DataSource`接口的`com.dbaccess.BasicDataSource`类的实例。调用`*ds*.getConnection`方法将产生与`CUSTOMER_ACCOUNTS`数据库的连接。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `getConnection` method requires only the user name and password because
    the variable `*ds*` has the rest of the information necessary for establishing
    a connection with the `CUSTOMER_ACCOUNTS` database, such as the database name
    and location, in its properties.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`getConnection`方法仅需要用户名和密码，因为变量`*ds*`在其属性中具有与`CUSTOMER_ACCOUNTS`数据库建立连接所需的其余信息，如数据库名称和位置。'
- en: Advantages of DataSource Objects
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DataSource对象的优势
- en: Because of its properties, a `DataSource` object is a better alternative than
    the `DriverManager` class for getting a connection. Programmers no longer have
    to hard code the driver name or JDBC URL in their applications, which makes them
    more portable. Also, `DataSource` properties make maintaining code much simpler.
    If there is a change, the system administrator can update data source properties
    and not be concerned about changing every application that makes a connection
    to the data source. For example, if the data source were moved to a different
    server, all the system administrator would have to do is set the `serverName`
    property to the new server name.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其属性，`DataSource`对象是获取连接的比`DriverManager`类更好的选择。程序员不再需要在其应用程序中硬编码驱动程序名称或JDBC
    URL，这使它们更具可移植性。此外，`DataSource`属性使代码维护更加简单。如果有任何更改，系统管理员可以更新数据源属性，而不必担心更改每个连接到数据源的应用程序。例如，如果数据源被移动到不同的服务器，系统管理员只需将`serverName`属性设置为新服务器名称。
- en: Aside from portability and ease of maintenance, using a `DataSource` object
    to get connections can offer other advantages. When the `DataSource` interface
    is implemented to work with a `ConnectionPoolDataSource` implementation, all of
    the connections produced by instances of that `DataSource` class will automatically
    be pooled connections. Similarly, when the `DataSource` implementation is implemented
    to work with an `XADataSource` class, all of the connections it produces will
    automatically be connections that can be used in a distributed transaction. The
    next section shows how to deploy these types of `DataSource` implementations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可移植性和易维护性之外，使用`DataSource`对象获取连接还可以提供其他优势。当`DataSource`接口被实现以与`ConnectionPoolDataSource`实现一起工作时，由该`DataSource`类的实例产生的所有连接将自动成为池化连接。同样，当`DataSource`实现被实现以与`XADataSource`类一起工作时，它产生的所有连接将自动成为可用于分布式事务的连接。下一节将展示如何部署这些类型的`DataSource`实现。
- en: Deploying Other DataSource Implementations
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署其他DataSource实现
- en: 'A system administrator or another person working in that capacity can deploy
    a `DataSource` object so that the connections it produces are pooled connections.
    To do this, he or she first deploys a `ConnectionPoolDataSource` object and then
    deploys a `DataSource` object implemented to work with it. The properties of the
    `ConnectionPoolDataSource` object are set so that it represents the data source
    to which connections will be produced. After the `ConnectionPoolDataSource` object
    has been registered with a JNDI naming service, the `DataSource` object is deployed.
    Generally only two properties must be set for the `DataSource` object: `description`
    and `dataSourceName`. The value given to the `dataSourceName` property is the
    logical name identifying the `ConnectionPoolDataSource` object previously deployed,
    which is the object containing the properties needed to make the connection.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员或其他从事该职能的人可以部署一个`DataSource`对象，以便它产生的连接是连接池连接。为此，他或她首先部署一个`ConnectionPoolDataSource`对象，然后部署一个实现与其配合工作的`DataSource`对象。设置`ConnectionPoolDataSource`对象的属性，以便它表示将生成连接的数据源。在`ConnectionPoolDataSource`对象已经注册到JNDI命名服务后，部署`DataSource`对象。通常只需设置`DataSource`对象的两个属性：`description`和`dataSourceName`。给定给`dataSourceName`属性的值是先前部署的标识`ConnectionPoolDataSource`对象的逻辑名称，该对象包含用于建立连接所需的属性。
- en: With the `ConnectionPoolDataSource` and `DataSource` objects deployed, you can
    call the method `DataSource.getConnection` on the `DataSource` object and get
    a pooled connection. This connection will be to the data source specified in the
    `ConnectionPoolDataSource` object's properties.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ConnectionPoolDataSource`和`DataSource`对象部署后，您可以在`DataSource`对象上调用`DataSource.getConnection`方法并获得一个连接池连接。此连接将连接到`ConnectionPoolDataSource`对象属性中指定的数据源。
- en: The following example describes how a system administrator for The Coffee Break
    would deploy a `DataSource` object implemented to provide pooled connections.
    The system administrator would typically use a deployment tool, so the code fragments
    shown in this section are the code that a deployment tool would execute.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例描述了如何为The Coffee Break的系统管理员部署一个实现提供连接池连接的`DataSource`对象。系统管理员通常会使用部署工具，因此本节中显示的代码片段是部署工具将执行的代码。
- en: To get better performance, The Coffee Break company has bought a JDBC driver
    from DB Access, Inc. that includes the class `com.dbaccess.ConnectionPoolDS`,
    which implements the `ConnectionPoolDataSource` interface. The system administrator
    creates an instance of this class, sets its properties, and registers it with
    a JNDI naming service. The Coffee Break has bought its `DataSource` class, `com.applogic.PooledDataSource`,
    from its EJB server vendor, Application Logic, Inc. The class `com.applogic.PooledDataSource`
    implements connection pooling by using the underlying support provided by the
    `ConnectionPoolDataSource` class `com.dbaccess.ConnectionPoolDS`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的性能，The Coffee Break 公司从DB Access, Inc.购买了一个JDBC驱动程序，其中包括实现`ConnectionPoolDataSource`接口的`com.dbaccess.ConnectionPoolDS`类。系统管理员创建此类的实例，设置其属性，并将其注册到JNDI命名服务中。The
    Coffee Break从其EJB服务器供应商Application Logic, Inc.购买了其`DataSource`类`com.applogic.PooledDataSource`。`com.applogic.PooledDataSource`类通过使用`ConnectionPoolDataSource`类`com.dbaccess.ConnectionPoolDS`提供的底层支持来实现连接池。
- en: 'The `ConnectionPoolDataSource` object must be deployed first. The following
    code creates an instance of `com.dbaccess.ConnectionPoolDS` and sets its properties:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 必须首先部署`ConnectionPoolDataSource`对象。以下代码创建了`com.dbaccess.ConnectionPoolDS`的实例并设置其属性：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the `ConnectionPoolDataSource` object has been deployed, the system administrator
    deploys the `DataSource` object. The following code registers the `com.dbaccess.ConnectionPoolDS`
    object `*cpds*` with a JNDI naming service. Note that the logical name being associated
    with the `*cpds*` variable has the subcontext `pool` added under the subcontext
    `jdbc`, which is similar to adding a subdirectory to another subdirectory in a
    hierarchical file system. The logical name of any instance of the class `com.dbaccess.ConnectionPoolDS`
    will always begin with `jdbc/pool`. Oracle recommends putting all `ConnectionPoolDataSource`
    objects under the subcontext `jdbc/pool`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署`ConnectionPoolDataSource`对象后，系统管理员部署`DataSource`对象。以下代码将`com.dbaccess.ConnectionPoolDS`对象`*cpds*`注册到JNDI命名服务中。请注意，与`*cpds*`变量关联的逻辑名称在`jdbc`的子上下文下添加了`pool`，类似于在分层文件系统中的另一个子目录下添加子目录。`com.dbaccess.ConnectionPoolDS`类的任何实例的逻辑名称始终以`jdbc/pool`开头。Oracle建议将所有`ConnectionPoolDataSource`对象放在`jdbc/pool`子上下文下：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, the `DataSource` class that is implemented to interact with the `*cpds*`
    variable and other instances of the `com.dbaccess.ConnectionPoolDS` class is deployed.
    The following code creates an instance of this class and sets its properties.
    Note that only two properties are set for this instance of `com.applogic.PooledDataSource`.
    The `description` property is set because it is always required. The other property
    that is set, `dataSourceName`, gives the logical JNDI name for `*cpds*`, which
    is an instance of the `com.dbaccess.ConnectionPoolDS` class. In other words, `*cpds*`
    represents the `ConnectionPoolDataSource` object that will implement connection
    pooling for the `DataSource` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现与`*cpds*`变量和`com.dbaccess.ConnectionPoolDS`类的其他实例交互的`DataSource`类被部署。下面的代码创建了这个类的一个实例并设置了其属性。请注意，为`com.applogic.PooledDataSource`的这个实例只设置了两个属性。设置`description`属性是因为它总是必需的。另一个设置的属性是`dataSourceName`，为`*cpds*`给出了逻辑JNDI名称，它是`com.dbaccess.ConnectionPoolDS`类的一个实例。换句话说，`*cpds*`代表了将为`DataSource`对象实现连接池的`ConnectionPoolDataSource`对象。
- en: 'The following code, which would probably be executed by a deployment tool,
    creates a `PooledDataSource` object, sets its properties, and binds it to the
    logical name `jdbc/fastCoffeeDB`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码，可能会被部署工具执行，创建了一个`PooledDataSource`对象，设置了其属性，并将其绑定到逻辑名称`jdbc/fastCoffeeDB`：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, a `DataSource` object is deployed from which an application can
    get pooled connections to the database `COFFEEBREAK`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，部署了一个`DataSource`对象，应用程序可以从中获取到数据库`COFFEEBREAK`的连接池连接。
- en: Getting and Using Pooled Connections
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和使用连接池连接
- en: A *connection pool* is a cache of database connection objects. The objects represent
    physical database connections that can be used by an application to connect to
    a database. At run time, the application requests a connection from the pool.
    If the pool contains a connection that can satisfy the request, it returns the
    connection to the application. If no connections are found, a new connection is
    created and returned to the application. The application uses the connection to
    perform some work on the database and then returns the object back to the pool.
    The connection is then available for the next connection request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接池*是数据库连接对象的缓存。这些对象代表了可以被应用程序用来连接数据库的物理数据库连接。在运行时，应用程序从连接池请求连接。如果连接池包含可以满足请求的连接，则将连接返回给应用程序。如果找不到连接，则创建一个新连接并返回给应用程序。应用程序使用连接对数据库执行一些工作，然后将对象返回到连接池。连接随后可用于下一个连接请求。'
- en: Connection pools promote the reuse of connection objects and reduce the number
    of times that connection objects are created. Connection pools significantly improve
    performance for database-intensive applications because creating connection objects
    is costly both in terms of time and resources.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池促进了连接对象的重复使用，减少了连接对象被创建的次数。连接池显著提高了数据库密集型应用的性能，因为创建连接对象在时间和资源方面都是昂贵的。
- en: 'Now that these `DataSource` and `ConnectionPoolDataSource` objects are deployed,
    a programmer can use the `DataSource` object to get a pooled connection. The code
    for getting a pooled connection is just like the code for getting a nonpooled
    connection, as shown in the following two lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些`DataSource`和`ConnectionPoolDataSource`对象已经部署，程序员可以使用`DataSource`对象获取连接池连接。获取连接池连接的代码与获取非连接池连接的代码类似，如下两行所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The variable `*ds*` represents a `DataSource` object that produces pooled connections
    to the database `COFFEEBREAK`. You need to retrieve this `DataSource` object only
    once because you can use it to produce as many pooled connections as needed. Calling
    the method `getConnection` on the `*ds*` variable automatically produces a pooled
    connection because the `DataSource` object that the `*ds*` variable represents
    was configured to produce pooled connections.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`*ds*`代表一个`DataSource`对象，用于向数据库`COFFEEBREAK`生成连接池连接。您只需要检索一次这个`DataSource`对象，因为您可以使用它生成所需数量的连接池连接。在`*ds*`变量上调用`getConnection`方法会自动生成一个连接池连接，因为`*ds*`变量表示的`DataSource`对象被配置为生成连接池连接。
- en: 'Connection pooling is generally transparent to the programmer. There are only
    two things you need to do when you are using pooled connections:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池对程序员通常是透明的。在使用连接池连接时，只需要做两件事情：
- en: 'Use a `DataSource` object rather than the `DriverManager` class to get a connection.
    In the following line of code, `*ds*` is a `DataSource` object implemented and
    deployed so that it will create pooled connections and `username` and `password`
    are variables that represent the credentials of the user that has access to the
    database:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DataSource`对象而不是`DriverManager`类来获取连接。在下面的代码行中，`*ds*`是一个已实现和部署的`DataSource`对象，它将创建池化连接，`username`和`password`是代表具有访问数据库权限的用户的凭据的变量：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use a `finally` statement to close a pooled connection. The following `finally`
    block would appear after the `try/catch` block that applies to the code in which
    the pooled connection was used:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`finally`语句来关闭池化连接。下面的`finally`块将出现在应用于使用池化连接的代码的`try/catch`块之后：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Otherwise, an application using a pooled connection is identical to an application
    using a regular connection. The only other thing an application programmer might
    notice when connection pooling is being done is that performance is better.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，使用池化连接的应用程序与使用常规连接的应用程序相同。当进行连接池化时，应用程序员可能注意到的唯一其他事情是性能更好。
- en: 'The following sample code gets a `DataSource` object that produces connections
    to the database `COFFEEBREAK` and uses it to update a price in the table `COFFEES`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码获取一个`DataSource`对象，该对象生成到数据库`COFFEEBREAK`的连接，并使用它来更新表`COFFEES`中的价格：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The connection in this code sample participates in connection pooling because
    the following are true:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例中的连接参与连接池化，因为以下条件为真：
- en: An instance of a class implementing `ConnectionPoolDataSource` has been deployed.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已部署了一个实现`ConnectionPoolDataSource`的类的实例。
- en: An instance of a class implementing `DataSource` has been deployed, and the
    value set for its `dataSourceName` property is the logical name that was bound
    to the previously deployed `ConnectionPoolDataSource` object.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已部署了一个实现`DataSource`的类的实例，并为其`dataSourceName`属性设置的值是之前部署的`ConnectionPoolDataSource`对象绑定的逻辑名称。
- en: 'Note that although this code is very similar to code you have seen before,
    it is different in the following ways:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管这段代码与您之前看到的代码非常相似，但在以下方面有所不同：
- en: It imports the `javax.sql`, `javax.ejb`, and `javax.naming` packages in addition
    to `java.sql`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导入了`javax.sql`、`javax.ejb`和`javax.naming`包，以及`java.sql`。
- en: The `DataSource` and `ConnectionPoolDataSource` interfaces are in the `javax.sql`
    package, and the JNDI constructor `InitialContext` and method `Context.lookup`
    are part of the `javax.naming` package. This particular example code is in the
    form of an EJB component that uses API from the `javax.ejb` package. The purpose
    of this example is to show that you use a pooled connection the same way you use
    a nonpooled connection, so you need not worry about understanding the EJB API.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataSource`和`ConnectionPoolDataSource`接口位于`javax.sql`包中，JNDI构造函数`InitialContext`和方法`Context.lookup`属于`javax.naming`包。这个特定的示例代码是以一个使用`javax.ejb`包中的API的EJB组件的形式呈现的。这个示例的目的是展示您使用池化连接的方式与使用非池化连接的方式相同，因此您不必担心理解EJB
    API。'
- en: It uses a `DataSource` object to get a connection instead of using the `DriverManager`
    facility.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`DataSource`对象来获取连接，而不是使用`DriverManager`工具。
- en: It uses a `finally` block to ensure that the connection is closed.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用一个`finally`块来确保连接被关闭。
- en: Getting and using a pooled connection is similar to getting and using a regular
    connection. When someone acting as a system administrator has deployed a `ConnectionPoolDataSource`
    object and a `DataSource` object properly, an application uses that `DataSource`
    object to get a pooled connection. An application should, however, use a `finally`
    block to close the pooled connection. For simplicity, the preceding example used
    a `finally` block but no `catch` block. If an exception is thrown by a method
    in the `try` block, it will be thrown by default, and the `finally` clause will
    be executed in any case.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和使用池化连接与获取和使用常规连接类似。当某人作为系统管理员部署了一个`ConnectionPoolDataSource`对象和一个正确的`DataSource`对象时，应用程序将使用该`DataSource`对象来获取池化连接。然而，应用程序应该使用一个`finally`块来关闭池化连接。为简单起见，前面的示例使用了一个`finally`块但没有`catch`块。如果`try`块中的方法抛出异常，它将默认抛出，并且`finally`子句将在任何情况下执行。
- en: Deploying Distributed Transactions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署分布式事务
- en: '`DataSource` objects can be deployed to get connections that can be used in
    distributed transactions. As with connection pooling, two different class instances
    must be deployed: an `XADataSource` object and a `DataSource` object that is implemented
    to work with it.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以部署`DataSource`对象以获取可用于分布式事务的连接。与连接池一样，必须部署两个不同的类实例：一个`XADataSource`对象和一个实现与其一起工作的`DataSource`对象。
- en: Suppose that the EJB server that The Coffee Break entrepreneur bought includes
    the `DataSource` class `com.applogic.TransactionalDS`, which works with an `XADataSource`
    class such as `com.dbaccess.XATransactionalDS`. The fact that it works with any
    `XADataSource` class makes the EJB server portable across JDBC drivers. When the
    `DataSource` and `XADataSource` objects are deployed, the connections produced
    will be able to participate in distributed transactions. In this case, the class
    `com.applogic.TransactionalDS` is implemented so that the connections produced
    are also pooled connections, which will usually be the case for `DataSource` classes
    provided as part of an EJB server implementation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设The Coffee Break企业家购买的EJB服务器包括`com.applogic.TransactionalDS`类，该类与`com.dbaccess.XATransactionalDS`等`XADataSource`类一起工作。它可以与任何`XADataSource`类一起工作，使EJB服务器在JDBC驱动程序之间具有可移植性。当部署`DataSource`和`XADataSource`对象时，生成的连接将能够参与分布式事务。在这种情况下，`com.applogic.TransactionalDS`类被实现为生成的连接也是池化连接，这通常是作为EJB服务器实现的一部分提供的`DataSource`类的情况。
- en: 'The `XADataSource` object must be deployed first. The following code creates
    an instance of `com.dbaccess.XATransactionalDS` and sets its properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 必须首先部署`XADataSource`对象。以下代码创建`com.dbaccess.XATransactionalDS`的一个实例并设置其属性：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following code registers the `com.dbaccess.XATransactionalDS` object `*xads*`
    with a JNDI naming service. Note that the logical name being associated with `*xads*`
    has the subcontext `xa` added under `jdbc`. Oracle recommends that the logical
    name of any instance of the class `com.dbaccess.XATransactionalDS` always begin
    with `jdbc/xa`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`com.dbaccess.XATransactionalDS`对象`*xads*`注册到JNDI命名服务。请注意，与`*xads*`关联的逻辑名称在`jdbc`下添加了子上下文`xa`。Oracle建议`com.dbaccess.XATransactionalDS`类的任何实例的逻辑名称始终以`jdbc/xa`开头。
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, the `DataSource` object that is implemented to interact with `*xads*`
    and other `XADataSource` objects is deployed. Note that the `DataSource` class,
    `com.applogic.TransactionalDS`, can work with an `XADataSource` class from any
    JDBC driver vendor. Deploying the `DataSource` object involves creating an instance
    of the `com.applogic.TransactionalDS` class and setting its properties. The `dataSourceName`
    property is set to `jdbc/xa/distCoffeeDB`, the logical name associated with `com.dbaccess.XATransactionalDS`.
    This is the `XADataSource` class that implements the distributed transaction capability
    for the `DataSource` class. The following code deploys an instance of the `DataSource`
    class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 部署实现与`*xads*`和其他`XADataSource`对象交互的`DataSource`对象。请注意，`DataSource`类`com.applogic.TransactionalDS`可以与任何JDBC驱动程序供应商的`XADataSource`类一起使用。部署`DataSource`对象涉及创建`com.applogic.TransactionalDS`类的实例并设置其属性。`dataSourceName`属性设置为`jdbc/xa/distCoffeeDB`，这是与`com.dbaccess.XATransactionalDS`关联的逻辑名称。这是实现`DataSource`类的分布式事务能力的`XADataSource`类。以下代码部署`DataSource`类的一个实例：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that instances of the classes `com.applogic.TransactionalDS` and `com.dbaccess.XATransactionalDS`
    have been deployed, an application can call the method `getConnection` on instances
    of the `TransactionalDS` class to get a connection to the `COFFEEBREAK` database
    that can be used in distributed transactions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经部署了`com.applogic.TransactionalDS`和`com.dbaccess.XATransactionalDS`类的实例，应用程序可以调用`TransactionalDS`类的实例上的`getConnection`方法，以获取连接到`COFFEEBREAK`数据库的连接，该连接可用于分布式事务。
- en: Using Connections for Distributed Transactions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用连接进行分布式事务
- en: 'To get a connection that can be used for distributed transactions, must use
    a `DataSource` object that has been properly implemented and deployed, as shown
    in the section [Deploying Distributed Transactions](#deployment_distributed_transactions).
    With such a `DataSource` object, call the method `getConnection` on it. After
    you have the connection, use it just as you would use any other connection. Because
    `jdbc/distCoffeesDB` has been associated with an `XADataSource` object in a JNDI
    naming service, the following code produces a `Connection` object that can be
    used in distributed transactions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用于分布式事务的连接，必须使用已经正确实现和部署的`DataSource`对象，如[部署分布式事务](#deployment_distributed_transactions)部分所示。使用这样的`DataSource`对象，调用其上的`getConnection`方法。获得连接后，使用它就像使用任何其他连接一样。因为`jdbc/distCoffeesDB`已经与JNDI命名服务中的`XADataSource`对象关联，因此以下代码生成一个可用于分布式事务的`Connection`对象：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are some minor but important restrictions on how this connection is used
    while it is part of a distributed transaction. A transaction manager controls
    when a distributed transaction begins and when it is committed or rolled back;
    therefore, application code should never call the methods `Connection.commit`
    or `Connection.rollback`. An application should likewise never call `Connection.setAutoCommit(true)`,
    which enables the auto-commit mode, because that would also interfere with the
    transaction manager's control of the transaction boundaries. This explains why
    a new connection that is created in the scope of a distributed transaction has
    its auto-commit mode disabled by default. Note that these restrictions apply only
    when a connection is participating in a distributed transaction; there are no
    restrictions while the connection is not part of a distributed transaction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接作为分布式事务的一部分时，对其使用有一些次要但重要的限制。事务管理器控制分布式事务何时开始以及何时提交或回滚；因此，应用程序代码永远不应调用`Connection.commit`或`Connection.rollback`方法。应用程序也不应调用`Connection.setAutoCommit(true)`，这会启用自动提交模式，因为这也会干扰事务管理器对事务边界的控制。这就解释了为什么在分布式事务范围内创建的新连接默认情况下会禁用其自动提交模式。请注意，这些限制仅适用于连接参与分布式事务时；连接不参与分布式事务时没有限制。
- en: For the following example, suppose that an order of coffee has been shipped,
    which triggers updates to two tables that reside on different DBMS servers. The
    first table is a new `INVENTORY` table, and the second is the `COFFEES` table.
    Because these tables are on different DBMS servers, a transaction that involves
    both of them will be a distributed transaction. The code in the following example,
    which obtains a connection, updates the `COFFEES` table, and closes the connection,
    is the second part of a distributed transaction.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下示例，假设已经发货一份咖啡订单，这将触发对驻留在不同DBMS服务器上的两个表进行更新。第一个表是一个新的`INVENTORY`表，第二个是`COFFEES`表。因为这些表位于不同的DBMS服务器上，涉及它们两个的事务将是一个分布式事务。以下示例中的代码获取连接，更新`COFFEES`表，并关闭连接，是分布式事务的第二部分。
- en: Note that the code does not explicitly commit or roll back the updates because
    the scope of the distributed transaction is being controlled by the middle tier
    server's underlying system infrastructure. Also, assuming that the connection
    used for the distributed transaction is a pooled connection, the application uses
    a `finally` block to close the connection. This guarantees that a valid connection
    will be closed even if an exception is thrown, thereby ensuring that the connection
    is returned to the connection pool to be recycled.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码并没有显式提交或回滚更新，因为分布式事务的范围由中间层服务器的基础系统基础设施控制。此外，假设用于分布式事务的连接是一个连接池连接，应用程序使用`finally`块来关闭连接。这样可以确保即使抛出异常，也会关闭有效连接，从而确保连接被返回到连接池以进行回收利用。
- en: The following code sample illustrates an enterprise Bean, which is a class that
    implements the methods that can be called by a client computer. The purpose of
    this example is to demonstrate that application code for a distributed transaction
    is no different from other code except that it does not call the `Connection`
    methods `commit`, `rollback`, or `setAutoCommit(true)`. Therefore, you do not
    need to worry about understanding the EJB API that is used.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了一个企业 Bean，它是一个实现了可以被客户端计算机调用的方法的类。这个示例的目的是演示分布式事务的应用代码与其他代码没有任何不同，只是它不调用`Connection`方法`commit`、`rollback`或`setAutoCommit(true)`。因此，您不需要担心理解所使用的
    EJB API。
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
