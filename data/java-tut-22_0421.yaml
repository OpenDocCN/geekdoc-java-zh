- en: How to Use the Focus Subsystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用焦点子系统
- en: 原文：[https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html](https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html](https://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html)
- en: "Many components \x96 even those primarily operated with the mouse, such as\
    \ buttons \x96 can be operated with the keyboard. For a key press to affect a\
    \ component, the component must have the keyboard focus."
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组件 - 即使是主要通过鼠标操作的组件，如按钮 - 也可以通过键盘操作。要使按键影响组件，组件必须具有键盘焦点。
- en: "From the user's point of view, the component with the keyboard focus is generally\
    \ prominent \x96 with a dotted or black border, for example. The window containing\
    \ the component is also more prominent than other windows onscreen. These visual\
    \ cues let the user know to which component any typing will relate. Only one component\
    \ at a time in the window system can have the keyboard focus."
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，具有键盘焦点的组件通常很显眼 - 例如带有虚线或黑色边框。包含该组件的窗口也比屏幕上的其他窗口更显眼。这些视觉提示让用户知道任何键入将与哪个组件相关联。窗口系统中一次只能有一个组件具有键盘焦点。
- en: Exactly how a window gains the focus depends on the windowing system. There
    is no foolproof way, across all platforms, to ensure that a window gains the focus.
    On some operating systems, such as Microsoft Windows, the front window usually
    becomes the focused window. In these cases, the [`Window.toFront`](https://docs.oracle.com/javase/8/docs/api/java/awt/Window.html#toFront--)
    method moves the window to the front, thereby giving it the focus. However, on
    other operating systems, such as Solaris™ Operating System, the window manager
    may choose the focused window based on cursor position, and in these cases the
    behavior of the `Window.toFront` method is different.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口如何获得焦点取决于窗口系统。在所有平台上，没有绝对可靠的方法来确保窗口获得焦点。在某些操作系统上，例如 Microsoft Windows，前置窗口通常成为焦点窗口。在这些情况下，[`Window.toFront`](https://docs.oracle.com/javase/8/docs/api/java/awt/Window.html#toFront--)方法将窗口移至前台，从而使其获得焦点。但是，在其他操作系统上，例如
    Solaris™ 操作系统，窗口管理器可能根据光标位置选择焦点窗口，在这种情况下，`Window.toFront`方法的行为不同。
- en: 'A component generally gains the focus when the user clicks it, or when the
    user tabs between components, or otherwise interacts with a component. A component
    can also be given the focus programmatically, such as when its containing frame
    or dialog-box is made visible. This code snippet shows how to give a particular
    component the focus every time the window gains the focus:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击组件、在组件之间切换选项卡或以其他方式与组件交互时，组件通常会获得焦点。组件也可以通过编程方式获得焦点，例如当其包含的框架或对话框可见时。以下代码片段显示了如何在窗口获得焦点时每次都给特定组件焦点：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to ensure that a particular component gains the focus the first
    time a window is activated, you can call the [`requestFocusInWindow`](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#requestFocusInWindow--)
    method on the component after the component has been realized, but before the
    frame is displayed. The following sample code shows how this operation can be
    done:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要确保特定组件在窗口首次激活时获得焦点，可以在组件实现后但在框架显示之前在组件上调用[`requestFocusInWindow`](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#requestFocusInWindow--)方法。以下示例代码显示了如何执行此操作：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alternatively, you can apply a custom `FocusTraversalPolicy` to the frame and
    call the `getDefaultComponent` method to determine which component will gain the
    focus.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将自定义`FocusTraversalPolicy`应用于框架，并调用`getDefaultComponent`方法确定哪个组件将获得焦点。
- en: 'The rest of this section covers the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分涵盖以下主题：
- en: '[Introduction to the Focus Subsystem](#intro)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[焦点子系统简介](#intro)'
- en: '[Validating Input](#inputVerification)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[验证输入](#inputVerification)'
- en: '[Making a Custom Component Focusable](#focusable)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使自定义组件可聚焦](#focusable)'
- en: '[Customizing Focus Traversal](#customFocusTraversal)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自定义焦点遍历](#customFocusTraversal)'
- en: '[Tracking Focus Changes to Multiple Components](#trackingFocus)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跟踪多个组件的焦点变化](#trackingFocus)'
- en: '[Timing Focus Transfers](#transferTiming)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[焦点转移时间](#transferTiming)'
- en: '[The Focus API](#api)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[焦点 API](#api)'
- en: '[Focus Examples](#eg)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[焦点示例](#eg)'
- en: Introduction to the Focus Subsystem
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 焦点子系统简介
- en: 'The focus subsystem is designed to do the right thing as invisibly as possible.
    In most cases it behaves in a reasonable manner, and if it does not you can tweak
    its behavior in various ways. Some common scenarios might include:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 焦点子系统旨在尽可能隐形地执行正确操作。在大多数情况下，它的行为是合理的，如果不是，您可以以各种方式调整其行为。一些常见情况可能包括：
- en: The ordering is right but the first component with the focus is not set. As
    shown in a code snippet in the preceding section, you can use the `requestFocusInWindow`
    method to set the focus on a component when the window becomes visible.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序正确，但焦点未设置在第一个组件上。如前一节中的代码片段所示，您可以使用`requestFocusInWindow`方法在窗口可见时将焦点设置在组件上。
- en: The ordering is wrong. To fix this issue, you can change the containment hierarchy,
    you can change the order that the components are added to their containers, or
    you can create a custom focus traversal policy. For more details see [Customizing
    Focus Traversal](#customFocusTraversal).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序错误。要解决此问题，您可以更改包含层次结构，更改组件添加到其容器的顺序，或者创建自定义焦点遍历策略。有关更多详细信息，请参见[自定义焦点遍历](#customFocusTraversal)。
- en: A component must to be prevented from losing focus, or you need to check a value
    in a component before it loses focus. [Input verification](#inputVerification)
    is a solution to this problem.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件必须防止失去焦点，或者在组件失去焦点之前检查一个值。[输入验证](#inputVerification)是解决此问题的方法。
- en: A custom component is not getting the focus. To fix this issue, you need to
    make sure that it satisfies all the requirements outlined in [Making a Custom
    Component Focusable](#focusable).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义组件没有获得焦点。要解决此问题，您需要确保它满足[使自定义组件可聚焦](#focusable)中概述的所有要求。
- en: The `FocusConceptsDemo` example illustrates a few concepts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`FocusConceptsDemo`示例演示了一些概念。'
- en: '![The FocusConceptsDemo example](../Images/39e32a32957a8e2ed5a3ef14fcca1d58.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![FocusConceptsDemo示例](../Images/39e32a32957a8e2ed5a3ef14fcca1d58.png)'
- en: '* * *'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Try this:**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试这个：**'
- en: Click the Launch button to run FocusConceptsDemo using [Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)
    ([download JDK 7 or later](http://www.oracle.com/technetwork/java/javase/downloads/index.html)).
    Alternatively, to compile and run the example yourself, consult the [example index](../examples/misc/index.html#FocusConceptsDemo).[![Launches
    the FocusConceptsDemo application](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/FocusConceptsDemoProject/FocusConceptsDemo.jnlp)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“启动”按钮以使用[Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)运行FocusConceptsDemo（[下载
    JDK 7 或更高版本](http://www.oracle.com/technetwork/java/javase/downloads/index.html)）。或者，要自行编译和运行示例，请参考[示例索引](../examples/misc/index.html#FocusConceptsDemo)。[![启动FocusConceptsDemo应用程序](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/FocusConceptsDemoProject/FocusConceptsDemo.jnlp)
- en: If necessary, click the window to give it the focus.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，单击窗口以使其获得焦点。
- en: Move the focus from component to component using the Tab key.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Tab键从组件到组件移动焦点。
- en: You will notice that when the focus moves into the text area, it stays in the
    text area.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会注意到当焦点移入文本区域时，它会停留在文本区域中。
- en: Move the focus out of the text area using Control-Tab.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Control-Tab将焦点移出文本区域。
- en: Move the focus in the opposite direction using Shift-Tab.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Shift-Tab向相反方向移动焦点。
- en: Move the focus out of the text area in the opposite direction using Control-Shift-Tab.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Control-Shift-Tab向相反方向移出文本区域的焦点。
- en: '* * *'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `KeyboardFocusManager` is a critical element of the focus subsystem. It
    manages state and initiates changes. The keyboard manager tracks the *focus owner*
    — the component that receives typing from the keyboard. The *focused window* is
    the window that contains the focus owner.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyboardFocusManager`是焦点子系统的关键元素。它管理状态并启动更改。键盘管理器跟踪*焦点所有者* —— 接收键盘输入的组件。*焦点窗口*是包含焦点所有者的窗口。'
- en: '* * *'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**JWindow and focus:** To use a `JWindow` component in your GUI, you should
    know that the `JWindow` component''s owning frame must be visible in order for
    any components in the window to get the focus. By default, if you do not specify
    an owning frame for a `JWindow` component, an invisible owning frame is created
    for it. The result is that components in the `JWindow` component might not be
    able to get the focus. The solution is either to specify a visible owning frame
    when creating the [`JWindow`](https://docs.oracle.com/javase/8/docs/api/javax/swing/JWindow.html)
    component, or to use an undecorated [`JFrame`](../components/frame.html) component
    instead.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWindow 和焦点：** 在 GUI 中使用 `JWindow` 组件时，你应该知道 `JWindow` 组件的拥有框架必须可见，以便窗口中的任何组件能够获得焦点。默认情况下，如果你没有为
    `JWindow` 组件指定拥有框架，系统会为其创建一个不可见的拥有框架。结果是，`JWindow` 组件中的组件可能无法获得焦点。解决方法要么在创建 [`JWindow`](https://docs.oracle.com/javase/8/docs/api/javax/swing/JWindow.html)
    组件时指定一个可见的拥有框架，要么使用一个无装饰的 [`JFrame`](../components/frame.html) 组件代替。'
- en: '* * *'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'A *focus cycle* (or *focus traversal cycle*) is a set of components that share
    a common ancestor in the containment hierarchy. The *focus cycle root* is the
    container that is the root for a particular focus traversal cycle. By default,
    every `JWindow` and `JInternalFrame` component can be a focus cycle root. A focus
    cycle root can itself contain one or more focus cycle roots. The following Swing
    objects can be focus cycle roots: `JApplet`, `JDesktopPane`, `JDialog`, `JEditorPane`,
    `JFrame`, `JInternalFrame`, and `JWindow`. While it might appear that `JTable`
    and `JTree` objects are focus cycle roots, they are not.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*焦点循环*（或*焦点遍历循环*）是一组在包含层次结构中共享共同祖先的组件。*焦点循环根*是特定焦点遍历循环的根容器。默认情况下，每个 `JWindow`
    和 `JInternalFrame` 组件都可以是焦点循环根。焦点循环根本身可以包含一个或多个焦点循环根。以下 Swing 对象可以是焦点循环根：`JApplet`、`JDesktopPane`、`JDialog`、`JEditorPane`、`JFrame`、`JInternalFrame`
    和 `JWindow`。虽然 `JTable` 和 `JTree` 对象看起来可能是焦点循环根，但实际上它们不是。'
- en: A *focus traversal policy* determines the order in which a group of components
    are navigated. Swing provides the [``LayoutFocusTraversalPolicy``](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html)
    class, which decides the order of navigation based on layout manager-dependent
    factors, such as size, location, and orientation of components. Within a focus
    cycle, components can be navigated in a forward or backward direction. In a hierarchy
    of focus cycle roots, upwards traversal takes the focus out of the current cycle
    into the parent cycle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*焦点遍历策略*确定一组组件被导航的顺序。Swing 提供了 [`LayoutFocusTraversalPolicy`](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html)
    类，根据布局管理器相关因素（如组件的大小、位置和方向）决定导航顺序。在焦点循环中，组件可以向前或向后导航。在焦点循环根的层次结构中，向上遍历将焦点从当前循环中移出到父循环中。'
- en: 'In most Look and Feel models, components are navigated using the Tab and Shift-Tab
    keys. These keys are the default *focus traversal keys* and can be changed programmatically.
    For example, you can add Enter as a forward focus traversal key with the following
    four lines of code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数外观和感觉模型中，使用 Tab 和 Shift-Tab 键导航组件。这些键是默认的*焦点遍历键*，可以通过编程方式进行更改。例如，你可以通过以下四行代码将
    Enter 添加为前向焦点遍历键：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tab shifts the focus in the forward direction. Shift-Tab moves the focus in
    the backward direction. For example, in FocusConceptsDemo, the first button has
    the initial focus. Tabbing moves the focus through the buttons into the text area.
    Additional tabbing moves the cursor within the text area but not out of the text
    area because, inside a text area, Tab is *not* a focus traversal key. However,
    Control-Tab moves the focus out of the text area and into the first text field.
    Likewise, Control-Shift-Tab moves the focus out of the text area and into the
    previous component. The Control key is used by convention to move the focus out
    of any component that treats Tab in a special way, such as `JTable`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Tab 在正向方向中移动焦点。Shift-Tab 在反向方向中移动焦点。例如，在 FocusConceptsDemo 中，第一个按钮具有初始焦点。通过
    Tab 键将焦点移动到文本区域中的按钮。额外的 Tab 键将在文本区域内移动光标，但不会移出文本区域，因为在文本区域内，Tab *不*是焦点遍历键。然而，Control-Tab
    将焦点移出文本区域并进入第一个文本字段。同样，Control-Shift-Tab 将焦点移出文本区域并进入上一个组件。按照惯例，Control 键用于将焦点移出任何将
    Tab 视为特殊方式的组件，例如 `JTable`。
- en: You have just received a brief introduction to the focus architecture. If you
    want more details, see the specification for the [Focus Subsystem](https://docs.oracle.com/javase/8/docs/api/java/awt/doc-files/FocusSpec.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚收到了对焦点架构的简要介绍。如果您想了解更多细节，请参阅[焦点子系统](https://docs.oracle.com/javase/8/docs/api/java/awt/doc-files/FocusSpec.html)的规范。
- en: Validating Input
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入验证
- en: A common requirement of GUI design is a component that restricts the user's
    input — for example, a text field that allows only numeric input in decimal format
    (money, for example) or a text field that allows only 5 digits for a zip code.
    An easy-to-use [formatted text field](../components/formattedtextfield.html) component
    that allows input to be restricted to a variety of localizable formats. You can
    also specify a [custom formatter](../components/formattedtextfield.html) for the
    text field, which can perform special checking such as determining whether values
    are not only formatted correctly, but also reasonable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: GUI设计的一个常见要求是限制用户输入的组件，例如，只允许十进制格式（例如货币）的数字输入或者只允许邮政编码为5位数字的文本字段。一个易于使用的[格式化文本字段](../components/formattedtextfield.html)组件允许输入限制为各种本地化格式。您还可以为文本字段指定一个[自定义格式化程序](../components/formattedtextfield.html)，该格式化程序可以执行特殊检查，例如确定值不仅格式正确，而且合理。
- en: You can use an input verifier as an alternative to a custom formatter, or when
    you have a component that is not a text field. An input verifier allows you to
    reject specific values, such as a properly formatted but invalid zip code, or
    values outside of a desired range, for example a body temperature higher than
    110°F. To use an input verifier, you create a subclass of [``InputVerifier``](https://docs.oracle.com/javase/8/docs/api/javax/swing/InputVerifier.html),
    create an instance of your subclass, and set the instance as the input verifier
    for one or more components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用输入验证器作为自定义格式化程序的替代方案，或者当您有一个不是文本字段的组件时。输入验证器允许您拒绝特定值，例如格式正确但无效的邮政编码，或者超出所需范围的值，例如高于110°F的体温。要使用输入验证器，您需要创建一个[``InputVerifier``](https://docs.oracle.com/javase/8/docs/api/javax/swing/InputVerifier.html)的子类，创建您子类的实例，并将该实例设置为一个或多个组件的输入验证器。
- en: A component's input verifier is consulted whenever the component is about to
    lose the focus. If the component's value is not acceptable, the input verifier
    can take appropriate action, such as refusing to yield the focus on the component
    or replacing the user's input with the last valid value and then allowing the
    focus to transfer to the next component. However, `InputVerifier` is not called
    when the focus is transferred to another top-level component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的输入验证器在组件即将失去焦点时进行查询。如果组件的值不可接受，输入验证器可以采取适当的措施，例如拒绝将焦点移交给组件或者用上次有效值替换用户的输入，然后允许焦点转移到下一个组件。但是，当焦点转移到另一个顶级组件时，不会调用`InputVerifier`。
- en: The following two examples show mortgage calculators. One uses formatted text
    fields and the other uses input verification with standard text fields.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例展示了抵押贷款计算器。一个使用格式化文本字段，另一个使用标准文本字段进行输入验证。
- en: '![The InputVerificationDemo and example, which demonstrates](../Images/00ac7bac9c396662039789b466ba6e54.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![演示InputVerificationDemo和示例](../Images/00ac7bac9c396662039789b466ba6e54.png)'
- en: '* * *'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Try this:**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试这个：**'
- en: Click the Launch button to run the FormattedTextFieldDemo using [Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)
    ([download JDK 7 or later](http://www.oracle.com/technetwork/java/javase/downloads/index.html)).
    Alternatively, to compile and run the example yourself, consult the [example index](../examples/components/index.html#FormattedTextFieldDemo).[![Launches
    the FormattedTextFieldDemo application](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/FormattedTextFieldDemoProject/FormattedTextFieldDemo.jnlp)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“启动”按钮以使用[Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)运行FormattedTextFieldDemo（[下载
    JDK 7 或更高版本](http://www.oracle.com/technetwork/java/javase/downloads/index.html)）。或者，要自行编译和运行示例，请参考[示例索引](../examples/components/index.html#FormattedTextFieldDemo)。[![启动FormattedTextFieldDemo应用程序](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/FormattedTextFieldDemoProject/FormattedTextFieldDemo.jnlp)
- en: Click the Launch button to run the InputVerificationDemo using [Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)
    ([download JDK 7 or later](http://www.oracle.com/technetwork/java/javase/downloads/index.html)).
    Alternatively, to compile and run the example yourself, consult the [example index](../examples/misc/index.html#InputVerificationDemo).[![Launches
    the InputVerificationDemo application](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/InputVerificationDemoProject/InputVerificationDemo.jnlp)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“启动”按钮以使用[Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)运行InputVerificationDemo（[下载JDK
    7或更高版本](http://www.oracle.com/technetwork/java/javase/downloads/index.html)）。或者，要自行编译和运行示例，请参考[示例索引](../examples/misc/index.html#InputVerificationDemo)。[![启动InputVerificationDemo应用程序](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/InputVerificationDemoProject/InputVerificationDemo.jnlp)
- en: Compare the two mortgage calculators side by side. You will see that the input
    verification demo specifies valid input values in the associated label for each
    editable text field. Try entering badly formatted values in both examples to observe
    behavior. Then try entering a properly formatted, but unacceptable value.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个抵押贷款计算器并排放置。您会发现输入验证演示为每个可编辑文本字段的相关标签指定了有效的输入值。尝试在两个示例中输入格式不正确的值以观察行为。然后尝试输入格式正确但不可接受的值。
- en: '* * *'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'You can find the code for the Input Verification demo in [`InputVerificationDemo.java`](../examples/misc/InputVerificationDemoProject/src/misc/InputVerificationDemo.java).
    Here is the code for the `InputVerifier` subclass, `MyVerifier`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[`InputVerificationDemo.java`](../examples/misc/InputVerificationDemoProject/src/misc/InputVerificationDemo.java)中找到输入验证演示的代码。以下是`MyVerifier`的`InputVerifier`子类的代码：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `verify` method is implemented to detect invalid values but does
    nothing else. The `verify` method exists only to determine whether the input is
    valid — it should never bring up a dialog-box or cause any other side effects.
    The `shouldYieldFocus` method calls `verify` and, if a values is invalid, sets
    it to the minimum or maximum value. The `shouldYieldFocus` method is allowed to
    cause side effects, in this case, it always formats the text field and may also
    change its value. In our example, the `shouldYieldFocus` method always returns
    true so that the transfer of the focus is never actually prevented. This is just
    one way verification can be implemented. Find another version of this demo called
    [`InputVerificationDialogDemo`](../examples/misc/index.html#InputVerificationDialogDemo)
    that puts up a dialog-box when user input is invalid and requires the user to
    enter a legal value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`verify`方法被实现用于检测无效值，但不执行其他操作。`verify`方法仅用于确定输入是否有效，不应弹出对话框或引起其他任何副作用。`shouldYieldFocus`方法调用`verify`，如果值无效，则将其设置为最小值或最大值。`shouldYieldFocus`方法允许引起副作用，在本例中，它始终格式化文本字段，还可能更改其值。在我们的示例中，`shouldYieldFocus`方法始终返回true，以确保焦点的传递实际上从未被阻止。这只是验证可以实现的一种方式。查找另一个名为[`InputVerificationDialogDemo`](../examples/misc/index.html#InputVerificationDialogDemo)的演示的另一个版本，当用户输入无效时会弹出对话框，并要求用户输入合法值。
- en: 'The input verifier is installed using the `setInputVerifier` method of the
    `JComponent` class. For example, the `InputVerificationDemo` has the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`JComponent`类的`setInputVerifier`方法安装输入验证器。例如，`InputVerificationDemo`具有以下代码：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Making a Custom Component Focusable
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使自定义组件可聚焦
- en: 'For a component to gain the focus, it must satisfy three requirements: it must
    be visible, enabled, and focusable. An input map may also be given. For more information
    about input map, read [How to Use Key Bindings](../misc/keybinding.html).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使组件获得焦点，必须满足三个要求：可见、启用和可聚焦。还可以提供输入映射。有关输入映射的更多信息，请阅读[如何使用键绑定](../misc/keybinding.html)。
- en: 'The [TrackFocusDemo](#trackfocusdemo) example defines the simple component
    `Picture`. Its constructor is shown below:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[TrackFocusDemo](#trackfocusdemo)示例定义了简单的组件`Picture`。其构造函数如下所示：'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The call to the `setFocusable(true)` method makes the component focusable. If
    you explicitly give your component key bindings in its `WHEN_FOCUSED` input map,
    you do not need to call the `setFocusable` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`setFocusable(true)`方法使组件可聚焦。如果在其`WHEN_FOCUSED`输入映射中显式为组件指定键绑定，则无需调用`setFocusable`方法。
- en: To visually show changes in the focus (by drawing a red border only when the
    component has the focus), `Picture` has a [focus listener](../events/focuslistener.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在焦点发生变化时进行可视化显示（仅在组件具有焦点时绘制红色边框），`Picture`具有一个[焦点监听器](../events/focuslistener.html)。
- en: 'To gain the focus when the user clicks on the picture, the component has a
    [mouse listener](../events/mouselistener.html). The listener''s `mouseClicked`
    method requests for the focus to be transferred to the picture. Here is the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击图片时获得焦点时，组件具有[鼠标监听器](../events/mouselistener.html)。监听器的`mouseClicked`方法请求将焦点转移到图片。以下是代码：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See [Tracking Focus Changes to Multiple Components](#trackingFocus) for more
    discussion of the TrackFocusDemo example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 TrackFocusDemo 示例的更多讨论，请参见[跟踪多个组件的焦点变化](#trackingFocus)。
- en: Customizing Focus Traversal
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义焦点遍历
- en: The focus subsystem determines a default order that is applied when using the
    focus traversal keys (such as Tab) to navigate. The policy of a Swing application
    is determined by [`LayoutFocusTraversalPolicy`](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html)
    . You can set a focus traversal policy on any `Container` by using the [`setFocusCycleRoot`](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusCycleRoot-boolean-)
    method. However, if the container is not a focus cycle root, it may have no apparent
    effect. Alternatively you can pass focus traversal policy providers to the `FocusTraversalPolicy`
    methods instead of focus cycle roots. Use the [`isFocusTraversalPolicyProvider()`](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#isFocusTraversalPolicyProvider--)
    method to determine whether a `Container` is a focus traversal policy provider.
    Use the [`setFocusTraversalPolicyProvider()`](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusTraversalPolicyProvider-boolean-)
    method to set a container for providing focus traversal policy.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 焦点子系统确定了在使用焦点遍历键（如 Tab 键）导航时应用的默认顺序。Swing 应用程序的策略由[`LayoutFocusTraversalPolicy`](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html)确定。您可以通过使用[`setFocusCycleRoot`](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusCycleRoot-boolean-)方法在任何`Container`上设置焦点遍历策略。但是，如果容器不是焦点循环根，则可能没有明显效果。或者，您可以将焦点遍历策略提供者传递给`FocusTraversalPolicy`方法，而不是焦点循环根。使用[`isFocusTraversalPolicyProvider()`](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#isFocusTraversalPolicyProvider--)方法来确定`Container`是否是焦点遍历策略提供者。使用[`setFocusTraversalPolicyProvider()`](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusTraversalPolicyProvider-boolean-)方法设置一个容器来提供焦点遍历策略。
- en: The `FocusTraversalDemo` example demonstrates how to customize focus behavior.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`FocusTraversalDemo`示例演示了如何自定义焦点行为。'
- en: '![The Focus Traversal Demo, which demonstrates a custom FocusTraversalPolicy.](../Images/f1fa407f8ee576d55af55c445f6afba3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![焦点遍历演示，演示自定义 FocusTraversalPolicy。](../Images/f1fa407f8ee576d55af55c445f6afba3.png)'
- en: '* * *'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Try this:**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试这个：**'
- en: Click the Launch button to run FocusTraversalDemo using [Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)
    ([download JDK 7 or later](http://www.oracle.com/technetwork/java/javase/downloads/index.html)).
    Alternatively, to compile and run the example yourself, consult the [example index](../examples/misc/index.html#FocusTraversalDemo).[![Launches
    the FocusTraversalDemo application](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/FocusTraversalDemoProject/FocusTraversalDemo.jnlp)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“启动”按钮以使用[Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)运行
    FocusTraversalDemo（[下载 JDK 7 或更高版本](http://www.oracle.com/technetwork/java/javase/downloads/index.html)）。或者，要自行编译和运行示例，请参考[示例索引](../examples/misc/index.html#FocusTraversalDemo)。[![启动
    FocusTraversalDemo 应用程序](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/FocusTraversalDemoProject/FocusTraversalDemo.jnlp)
- en: Click the window, if necessary, to give it the focus.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击窗口，如果需要，使其获得焦点。
- en: Note the focus order as you tab through the components. The focus order was
    determined by the order that the components were added to the content pane. Note
    also that the check box never gets the focus; we removed it from the focus cycle.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您通过组件进行制表时，请注意焦点顺序。焦点顺序是由组件添加到内容窗格的顺序确定的。还要注意，复选框永远不会获得焦点；我们将其从焦点循环中移除。
- en: To move the focus out of the table, use Control-Tab or Control-Shift-Tab.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将焦点移出表格，请使用 Control-Tab 或 Control-Shift-Tab。
- en: Click the **Custom FocusTraversalPolicy** check box. This box installs a custom
    focus traversal policy on the frame.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**自定义 FocusTraversalPolicy**复选框。此框在框架上安装了自定义焦点遍历策略。
- en: Try tabbing through the components again. Note that the focus order is now in
    left-to-right, top-down order.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次通过组件进行制表。请注意，焦点顺序现在是从左到右，从上到下的顺序。
- en: '* * *'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: You can find the demo's code in [`FocusTraversalDemo.java`](../examples/misc/FocusTraversalDemoProject/src/misc/FocusTraversalDemo.java).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[`FocusTraversalDemo.java`](../examples/misc/FocusTraversalDemoProject/src/misc/FocusTraversalDemo.java)中找到演示代码。
- en: 'The check box was removed from the focus cycle with this line of code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这行代码从焦点循环中移除复选框：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the application''s custom `FocusTraversalPolicy`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的自定义`FocusTraversalPolicy`：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To use a custom `FocusTraversalPolicy`, implement the following code on any
    focus cycle root.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自定义`FocusTraversalPolicy`，请在任何焦点循环根上实现以下代码。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can remove the custom focus traversal policy by setting the `FocusTraversalPolicy`
    to `null`, which will restore the default policy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`FocusTraversalPolicy`设置为`null`来删除自定义焦点遍历策略，这将恢复默认策略。
- en: Tracking Focus Changes to Multiple Components
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪多个组件的焦点更改
- en: In some situations an application may need to track which component has the
    focus. This information might be used to dynamically update menus or perhaps a
    status bar. If you need to track the focus only on specific components, it may
    make sense to implement a [focus event listener](../events/focuslistener.html).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，应用程序可能需要跟踪具有焦点的组件。这些信息可能用于动态更新菜单或可能是状态栏。如果只需要在特定组件上跟踪焦点，可能有必要实现[焦点事件监听器](../events/focuslistener.html)。
- en: If a focus listener is not appropriate, you can instead register a `PropertyChangeListener`
    on the `KeyboardFocusManager`. The property change listener is notified of every
    change involving the focus, including changes to the focus owner, the focused
    window, and the default focus traversal policy. See the [KeyboardFocusManager
    Properties](#properties) table for a complete list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果焦点监听器不合适，您可以在`KeyboardFocusManager`上注册`PropertyChangeListener`。属性更改侦听器会通知涉及焦点的每次更改，包括焦点所有者、焦点窗口和默认焦点遍历策略的更改。查看[KeyboardFocusManager
    Properties](#properties)表以获取完整列表。
- en: The following example demonstrates tracking the focus owner by installing a
    property change listener on the keyboard focus manager.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示通过在键盘焦点管理器上安装属性更改侦听器来跟踪焦点所有者。
- en: '![The TrackFocusDemo example, which demonstrates tracking the focus owner.](../Images/bd6547099b041f1c6633043c5203b4bc.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![TrackFocusDemo示例，演示跟踪焦点所有者。](../Images/bd6547099b041f1c6633043c5203b4bc.png)'
- en: '* * *'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Try this:**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试这个：**'
- en: Click the Launch button to run TrackFocusDemo using [Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)
    ([download JDK 7 or later](http://www.oracle.com/technetwork/java/javase/downloads/index.html)).
    Alternatively, to compile and run the example yourself, consult the [example index](../examples/misc/index.html#TrackFocusDemo).[![Launches
    the TrackFocusDemo application](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TrackFocusDemoProject/TrackFocusDemo.jnlp)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“启动”按钮以使用[Java™ Web Start](http://www.oracle.com/technetwork/java/javase/javawebstart/index.html)运行TrackFocusDemo（[下载JDK
    7或更高版本](http://www.oracle.com/technetwork/java/javase/downloads/index.html)）。或者，要自行编译和运行示例，请参考[示例索引](../examples/misc/index.html#TrackFocusDemo)。[![启动TrackFocusDemo应用程序](../Images/4707a69a17729d71c56b2bdbbb4cc61c.png)](https://docs.oracle.com/javase/tutorialJWS/samples/uiswing/TrackFocusDemoProject/TrackFocusDemo.jnlp)
- en: If necessary, click the window to give it the focus.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，点击窗口使其获得焦点。
- en: The window shows six images, each of which is displayed by a `Picture` component.
    The `Picture` that has the focus is indicated with a red border. A label at the
    bottom of the window describes the `Picture` that has the focus.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 窗口显示六幅图像，每幅图像都由`Picture`组件显示。具有焦点的`Picture`以红色边框标识。窗口底部的标签描述具有焦点的`Picture`。
- en: Move the focus to another `Picture` by using Tab or Shift-Tab, or by clicking
    an image. Because a property change listener has been registered on the keyboard
    focus manager, the change in focus is detected and the label is updated appropriately.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用Tab或Shift-Tab移动焦点到另一个`Picture`，或者通过单击图像来移动焦点。由于在键盘焦点管理器上注册了属性更改侦听器，因此焦点的变化会被检测到，并且标签会相应更新。
- en: '* * *'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'You can view the demo''s code in [`TrackFocusDemo.java`](../examples/misc/TrackFocusDemoProject/src/misc/TrackFocusDemo.java).
    The custom component used for drawing the images can be found in [`Picture.java`](../examples/misc/TrackFocusDemoProject/src/misc/Picture.java).
    Here is the code that defines and installs the property change listener:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[`TrackFocusDemo.java`](../examples/misc/TrackFocusDemoProject/src/misc/TrackFocusDemo.java)中查看演示代码。用于绘制图像的自定义组件可以在[`Picture.java`](../examples/misc/TrackFocusDemoProject/src/misc/Picture.java)中找到。以下是定义和安装属性更改侦听器的代码：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The custom component, `Picture`, is responsible for drawing the image. All
    six components are defined in this manner:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义组件`Picture`负责绘制图像。所有六个组件都是这样定义的：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Timing Focus Transfers
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时焦点转移
- en: 'Focus transfers are asynchronous. This quality can lead to some odd timing-related
    problems and assumptions, especially during automatic transfers of the focus.
    For example, imagine an application with a window containing a Start button, a
    Cancel button and a text field. The components are added in this order:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 焦点转移是异步的。这种特性可能会导致一些奇怪的与时间相关的问题和假设，尤其是在焦点的自动转移过程中。例如，想象一个包含“开始”按钮、“取消”按钮和文本字段的窗口的应用程序。这些组件按照这个顺序添加：
- en: Start button
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始按钮
- en: Text field
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本字段
- en: Cancel button
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消按钮
- en: 'When the application is launched, the `LayoutFocusTraversalPolicy` determines
    the focus traversal policy — in this case, it is the order that the components
    were added to their container. In this example, the desired behavior is that the
    Start button has the initial focus, and when the Start button is clicked, it is
    disabled, and then the Cancel button receives the focus. The correct way to implement
    this behavior would be to add the components to the container in the desired order
    or to create a custom focus traversal policy. If, for some reason, that is not
    possible, then you can implement this behavior with the following code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，`LayoutFocusTraversalPolicy`确定焦点遍历策略——在本例中，它是组件添加到其容器的顺序。在这个示例中，期望的行为是“开始”按钮具有初始焦点，当单击“开始”按钮时，它被禁用，然后“取消”按钮接收焦点。实现这种行为的正确方法是按照期望的顺序将组件添加到容器中，或者创建一个自定义的焦点遍历策略。如果由于某种原因无法实现这一点，那么可以使用以下代码片段实现这种行为：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As desired, the focus goes from the Start button to the Cancel button, rather
    than to the text field. But a different result would occur if the same methods
    were called in the opposite order as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如期望的那样，焦点从“开始”按钮转移到“取消”按钮，而不是文本字段。但是，如果以相反的顺序调用相同的方法，则会产生不同的结果，如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the focus is requested on the Cancel button before it has left
    the Start button. The call to the `requestFocusInWindow` method initiates the
    focus transfer, but it does not immediately move the focus to the Cancel button.
    When the Start button is disabled, the focus is transferred to the next component
    (so there is always a component with the focus) and, in this case, it would then
    move the focus to the text field, *not* to the Cancel button.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在“开始”按钮离开之前就请求了“取消”按钮的焦点。调用`requestFocusInWindow`方法会启动焦点转移，但不会立即将焦点移动到“取消”按钮。当“开始”按钮被禁用时，焦点会转移到下一个组件（因此总是有一个具有焦点的组件），在这种情况下，焦点会移动到文本字段，*而不是*“取消”按钮。
- en: 'There are several situations in which you need to make focus requests after
    all other changes that might affect the focus applies to:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况下，您需要在可能影响焦点的所有其他更改之后发出焦点请求：
- en: Hiding the focus owner.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏焦点所有者。
- en: Making the focus owner non-focusable.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使焦点所有者不可聚焦。
- en: Calling the `removeNotify` method on the focus owner.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在焦点所有者上调用`removeNotify`方法。
- en: Doing any of the above operations to the container of the focus owner, or causing
    changes to the focus policy so that the container no longer accepts the component
    as the focus owner.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对焦点所有者的容器执行上述任何操作，或者导致焦点策略发生更改，以使容器不再接受该组件作为焦点所有者。
- en: Disposing of the top-level window that contains the focus owner.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处置包含焦点所有者的顶层窗口。
- en: The Focus API
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 焦点API
- en: 'The following tables list the commonly used constructors and methods related
    to focus. The focus API falls into four categories:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了与焦点相关的常用构造函数和方法。焦点API分为四个类别：
- en: '[Useful Methods for Components](#focusMethods)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[组件的有用方法](#focusMethods)'
- en: '[Creating and Using a Custom FocusTraversalPolicy](#focustraversal)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建和使用自定义焦点遍历策略](#focustraversal)'
- en: '[Input Verification API](#inputverificationapi)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[输入验证API](#inputverificationapi)'
- en: '[KeyboardFocusManager Properties](#properties)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[KeyboardFocusManager属性](#properties)'
- en: For more detailed information about the focus architecture, see the specification
    for the [Focus Subsystem](https://docs.oracle.com/javase/8/docs/api/java/awt/doc-files/FocusSpec.html).
    You may also find [How to Write a Focus Listener](../events/focuslistener.html)
    useful.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有关焦点架构的更详细信息，请参阅[焦点子系统](https://docs.oracle.com/javase/8/docs/api/java/awt/doc-files/FocusSpec.html)的规范。您可能还会发现[如何编写焦点侦听器](../events/focuslistener.html)有用。
- en: Useful Methods for Components
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的有用方���
- en: '| Method (in `Component`) | Purpose |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 方法（在`Component`中） | 目的 |'
- en: '| [isFocusOwner()](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#isFocusOwner--)
    | Returns `true` if the component is the focus owner. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| [isFocusOwner()](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#isFocusOwner--)
    | 如果组件是焦点所有者，则返回`true`。 |'
- en: '| [setRequestFocusEnabled(boolean)](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#setRequestFocusEnabled-boolean-)
    [isRequestFocusEnabled()](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#isRequestFocusEnabled--)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| [setRequestFocusEnabled(boolean)](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#setRequestFocusEnabled-boolean-)
    [isRequestFocusEnabled()](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#isRequestFocusEnabled--)'
- en: (*in `JComponent`)* | Sets or checks on whether this component should get the
    focus. Setting the `setRequestFocusEnabled` to `false` typically prevents mouse
    clicks from giving the component the focus, while still allowing keyboard navigation
    to give the component the focus. This method applies only to components that receive
    mouse events. For example, you can use this method on a `JButton`, but not on
    a `JPanel`. If you write a custom component it is up to you to honor this property.
    This method is recommended over the `setFocusable` method and will allow your
    program to work better for users employing [assistive technologies](access.html).
    |
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (*in `JComponent`)* | 设置或检查此组件是否应获得焦点。将`setRequestFocusEnabled`设置为`false`通常会阻止鼠标点击使组件获得焦点，但仍允许键盘导航使组件获得焦点。此方法仅适用于接收鼠标事件的组件。例如，您可以在`JButton`上使用此方法，但不能在`JPanel`上使用。如果编写自定义组件，则需要遵守此属性。此方法比`setFocusable`方法更可取，并将使您的程序更适合使用[辅助技术](access.html)的用户。
    |
- en: '| [setFocusable(boolean)](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#setFocusable-boolean-)
    [isFocusable()](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#isFocusable--)
    | Sets or gets the focusable state of the component. A component must be focusable
    in order to gain the focus. When a component has been removed from the focus cycle
    with `setFocusable(false)`, it can no longer be navigated with the keyboard. The
    `setRequestFocusEnabled` method is recommended so that your program can be run
    by users employing [assistive technologies](access.html). |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| [setFocusable(boolean)](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#setFocusable-boolean-)
    [isFocusable()](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#isFocusable--)
    | 设置或获取组件的可聚焦状态。组件必须是可聚焦的才能获得焦点。当使用`setFocusable(false)`将组件从焦点循环中移除后，无法再使用键盘导航到该组件。建议使用`setRequestFocusEnabled`方法，以便您的程序可以被使用[辅助技术](access.html)的用户运行。
    |'
- en: '| [requestFocusInWindow()](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#requestFocusInWindow--)
    | Requests that this component should get the focus. The component''s window must
    be the current focused window. For this request to be granted a subclass of `JComponent`
    must be visible, enabled, and focusable, and have an input map for this request
    to be granted. It should not be assumed that the component has the focus until
    it fires a `FOCUS_GAINED` event. This method is preferred to the `requestFocus`
    method, which is platform-dependent. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| [requestFocusInWindow()](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#requestFocusInWindow--)
    | 请求此组件获取焦点。组件的窗口必须是当前焦点窗口。要满足此请求，`JComponent`的子类必须可见、启用且可聚焦，并且必须具有此请求的输入映射。在触发`FOCUS_GAINED`事件之前，不应假定组件已获得焦点。此方法优于依赖于平台的`requestFocus`方法。
    |'
- en: '| [setFocusTraversalKeys(int, Set)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusTraversalKeys-int-java.util.Set-)
    [getFocusTraversalKeys(int)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#getFocusTraversalKeys-int-)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| [setFocusTraversalKeys(int, Set)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusTraversalKeys-int-java.util.Set-)
    [getFocusTraversalKeys(int)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#getFocusTraversalKeys-int-)'
- en: '[areFocusTraversalKeysSet(int)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#areFocusTraversalKeysSet-int-)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[areFocusTraversalKeysSet(int)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#areFocusTraversalKeysSet-int-)'
- en: '(*in `java.awt.Container`*) | Sets or gets the focus traversal keys for a particular
    direction or determines whether any focus traversal keys have been explicitly
    set on this container. If no focus traversal keys have been set, they are inherited
    from an ancestor or from the keyboard focus manager. Focus traversal keys can
    be set for the following directions: `KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS`,
    `KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS` `KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS`,
    or `KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS`. If you set the `UP_CYCLE_TRAVERSAL_KEYS`
    or the `DOWN_CYCLE_TRAVERSAL_KEYS`, you must also invoke [`setImplicitDownCycleTraversal(false)`](https://docs.oracle.com/javase/8/docs/api/javax/swing/SortingFocusTraversalPolicy.html#setImplicitDownCycleTraversal-boolean-)
    on the focus traversal policy. |'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: (*在`java.awt.Container`中*) | 设置或获取特定方向的焦点遍历键，或确定此容器上是否已明确设置了任何焦点遍历键。如果未设置任何焦点遍历键，则会从祖先或键盘焦点管理器继承。可以为以下方向设置焦点遍历键：`KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS`、`KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS`、`KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS`或`KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS`。如果设置了`UP_CYCLE_TRAVERSAL_KEYS`或`DOWN_CYCLE_TRAVERSAL_KEYS`，还必须在焦点遍历策略上调用[`setImplicitDownCycleTraversal(false)`](https://docs.oracle.com/javase/8/docs/api/javax/swing/SortingFocusTraversalPolicy.html#setImplicitDownCycleTraversal-boolean-)。
- en: Creating and Using a Custom FocusTraversalPolicy
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和使用自定义焦点遍历策略
- en: '| Class or Method | Purpose |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 类或方法 | 目的 |'
- en: '| [LayoutFocusTraversalPolicy](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html)
    | The class that, by default, determines the focus traversal policy for Swing
    components. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| [LayoutFocusTraversalPolicy](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html)
    | 默认情况下确定Swing组件的焦点遍历策略的类。'
- en: '| [getComponentAfter(Container, Component)](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html#getComponentAfter-java.awt.Container-java.awt.Component-)
    | Given the component that is passed as input, returns the component that should
    next have the focus. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| [getComponentAfter(Container, Component)](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html#getComponentAfter-java.awt.Container-java.awt.Component-)
    | 给定作为输入的组件，返回下一个应该获得焦点的组件。'
- en: '| [getComponentBefore(Container, Component)](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html#getComponentBefore-java.awt.Container-java.awt.Component-)
    | Given the component that is passed as input, returns the component that should
    have the focus before this component. The method is used for backward tabbing.
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| [getComponentBefore(Container, Component)](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html#getComponentBefore-java.awt.Container-java.awt.Component-)
    | 给定作为输入的组件，返回在此组件之前应该获得焦点的组件。该方法用于向后切换。'
- en: '| [getDefaultComponent(Container)](https://docs.oracle.com/javase/8/docs/api/javax/swing/SortingFocusTraversalPolicy.html#getDefaultComponent-java.awt.Container-)
    (*in `javax.swing.SortingFocusTraversalPolicy`)* | Returns the component that
    should have the default focus. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| [getDefaultComponent(Container)](https://docs.oracle.com/javase/8/docs/api/javax/swing/SortingFocusTraversalPolicy.html#getDefaultComponent-java.awt.Container-)
    (*在`javax.swing.SortingFocusTraversalPolicy`中*) | 返回应该具有默认焦点的组件。'
- en: '| [getFirstComponent(Container)](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html#getFirstComponent-java.awt.Container-)
    | Returns the first component in the traversal cycle. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| [getFirstComponent(Container)](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html#getFirstComponent-java.awt.Container-)
    | 返回遍历循环中的第一个组件。'
- en: '| [getInitialComponent(Container)](https://docs.oracle.com/javase/8/docs/api/javax/swing/InternalFrameFocusTraversalPolicy.html#getInitialComponent-java.awt.Container-)
    | Returns the component that should receive the focus when a window is made visible
    for the first time. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| [getInitialComponent(Container)](https://docs.oracle.com/javase/8/docs/api/javax/swing/InternalFrameFocusTraversalPolicy.html#getInitialComponent-java.awt.Container-)
    | 返回当窗口首次可见时应该接收焦点的组件。'
- en: '| [getLastComponent(Container)](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html#getLastComponent-java.awt.Container-)
    | Returns the last component in the traversal cycle. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| [getLastComponent(Container)](https://docs.oracle.com/javase/8/docs/api/javax/swing/LayoutFocusTraversalPolicy.html#getLastComponent-java.awt.Container-)
    | 返回遍历循环中的最后一个组件。'
- en: '| [setFocusTraversalPolicy(FocusTraversalPolicy)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusTraversalPolicy-java.awt.FocusTraversalPolicy-)
    [getFocusTraversalPolicy(FocusTraversalPolicy)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#getFocusTraversalPolicy--)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '| [setFocusTraversalPolicy(FocusTraversalPolicy)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusTraversalPolicy-java.awt.FocusTraversalPolicy-)
    [getFocusTraversalPolicy(FocusTraversalPolicy)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#getFocusTraversalPolicy--)'
- en: (*in `java.awt.Container`*) | Sets or gets the focus traversal policy or determines
    if a policy has been set. Note that setting a focus traversal policy on a container
    that is not the focus cycle root may have no apparent effect. A value of `null`
    means that a policy has not been explicitly set. If no policy has been set, a
    policy is inherited from the parent focus cycle root. |
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (*在 `java.awt.Container` 中*) | 设置或获取焦点遍历策略，或确定是否已设置策略。请注意，在不是焦点循环根的容器上设置焦点遍历策略可能没有明显效果。`null`
    值表示未明确设置策略。如果未设置策略，则从父焦点循环根继承策略。 |
- en: '| [isFocusCycleRoot()](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#isFocusCycleRoot--)
    [setFocusCycleRoot(boolean)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusCycleRoot-boolean-)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '| [isFocusCycleRoot()](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#isFocusCycleRoot--)
    [setFocusCycleRoot(boolean)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusCycleRoot-boolean-)'
- en: (*in `java.awt.Container`*) | Checks or sets whether a container is the root
    of a focus traversal cycle. |
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (*在 `java.awt.Container` 中*) | 检查或设置容器是否是焦点遍历循环的根。 |
- en: '| [isFocusTraversalPolicyProvider()](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#isFocusTraversalPolicyProvider--)
    [setFocusTraversalPolicyProvider(boolean)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusTraversalPolicyProvider-boolean-)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '| [isFocusTraversalPolicyProvider()](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#isFocusTraversalPolicyProvider--)
    [setFocusTraversalPolicyProvider(boolean)](https://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#setFocusTraversalPolicyProvider-boolean-)'
- en: (*in `java.awt.Container`*) | Checks or sets whether a container will be used
    to provide focus traversal policy. |
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (*在 `java.awt.Container` 中*) | 检查或设置容器是否用于提供焦点遍历策略。 |
- en: Input Verification API
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证 API
- en: '| Class or Method | Purpose |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 类或方法 | 目的 |'
- en: '| [InputVerifier](https://docs.oracle.com/javase/8/docs/api/javax/swing/InputVerifier.html)
    | Abstract class that allows input validation via the focus mechanism. When an
    attempt is made to shift the focus from a component containing an input verifier,
    the focus is not relinquished until the verifier is satisfied. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| [InputVerifier](https://docs.oracle.com/javase/8/docs/api/javax/swing/InputVerifier.html)
    | 允许通过焦点机制进行输入验证的抽象类。当尝试从包含输入验证器的组件转移焦点时，直到验证器满足为止焦点不会放弃。 |'
- en: '| [shouldYieldFocus(JComponent)](https://docs.oracle.com/javase/8/docs/api/javax/swing/InputVerifier.html#shouldYieldFocus-javax.swing.JComponent-)
    *(in `InputVerifier`)* | When a component has an input verifier, this method is
    called by the system to determine whether the focus can leave this component.
    This method may cause side effects, such as bringing up a dialog-box. If this
    method returns `false`, the focus remains on the component passed in to the method.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| [shouldYieldFocus(JComponent)](https://docs.oracle.com/javase/8/docs/api/javax/swing/InputVerifier.html#shouldYieldFocus-javax.swing.JComponent-)
    *(在 `InputVerifier` 中)* | 当组件具有输入验证器时，系统调用此方法以确定焦点是否可以离开此组件。此方法可能引起副作用，如弹出对话框。如果此方法返回
    `false`，焦点将保留在传递给方法的组件上。 |'
- en: '| [verify(JComponent)](https://docs.oracle.com/javase/8/docs/api/javax/swing/InputVerifier.html#verify-javax.swing.JComponent-)
    *(in `InputVerifier`)* | You need to override this method to check that the component''s
    input is valid. It should return `true` if valid, otherwise return `false`. This
    method should not cause any side effects, such as bringing up a dialog-box. This
    method is called by `shouldYieldFocus`. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| [verify(JComponent)](https://docs.oracle.com/javase/8/docs/api/javax/swing/InputVerifier.html#verify-javax.swing.JComponent-)
    *(在 `InputVerifier` 中)* | 您需要重写此方法以检查组件的输入是否有效。如果有效，应返回 `true`，否则返回 `false`。此方法不应引起任何副作用，如弹出对话框。此方法由
    `shouldYieldFocus` 调用。 |'
- en: '| [setInputVerifier(inputVerifier)](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#setInputVerifier-javax.swing.InputVerifier-)
    [getInputVerifier()](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#getInputVerifier--)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '| [setInputVerifier(inputVerifier)](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#setInputVerifier-javax.swing.InputVerifier-)
    [getInputVerifier()](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#getInputVerifier--)'
- en: '*(in `JComponent`)* | Sets or gets the input verifier assigned to the component.
    By default, components have no input verifier. |'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*(在`JComponent`中)* | 设置或获取分配给组件的输入验证器。默认情况下，组件没有输入验证器。 |'
- en: '| [setVerifyInputWhenFocusTarget(boolean)](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#setVerifyInputWhenFocusTarget-boolean-)
    [getVerifyInputWhenFocusTarget()](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#getVerifyInputWhenFocusTarget--)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '| [setVerifyInputWhenFocusTarget(boolean)](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#setVerifyInputWhenFocusTarget-boolean-)
    [getVerifyInputWhenFocusTarget()](https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#getVerifyInputWhenFocusTarget--)
    |'
- en: '*(in `JComponent`)* | Sets or gets whether the input verifier for the current
    focus owner is called before this component requests the focus. The default is
    `true`. This method should be set to `false` for components, such as a Cancel
    button or a scroll bar, that should receive the focus even if input is invalid.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*(在`JComponent`中)* | 设置或获取当前焦点所有者的输入验证器在此组件请求焦点之前是否被调用。默认值为`true`。对于应该在输入无效时接收焦点的组件（例如取消按钮或滚动条），应将此方法设置为`false`。
    |'
- en: KeyboardFocusManager Properties
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘焦点管理器属性
- en: This table defines the bound properties for [`KeyboardFocusManager`](https://docs.oracle.com/javase/8/docs/api/java/awt/KeyboardFocusManager.html).
    A listener can be registered for these properties by calling [`addPropertyChangeListener`](https://docs.oracle.com/javase/8/docs/api/java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.beans.PropertyChangeListener-).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此表定义了[`KeyboardFocusManager`](https://docs.oracle.com/javase/8/docs/api/java/awt/KeyboardFocusManager.html)的绑定属性。可以通过调用[`addPropertyChangeListener`](https://docs.oracle.com/javase/8/docs/api/java/awt/KeyboardFocusManager.html#addPropertyChangeListener-java.beans.PropertyChangeListener-)方法为这些属性注册监听器。
- en: '| Property | Purpose |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 目的 |'
- en: '| focusOwner | The component that currently receives key events. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| focusOwner | 当前接收键事件的组件。 |'
- en: '| permanentFocusOwner | The component that most recently received a permanent
    `FOCUS_GAINED` event. Typically the same as `focusOwner`, unless a temporary focus
    change is currently in effect. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| permanentFocusOwner | 最近接收到永久`FOCUS_GAINED`事件的组件。通常与`focusOwner`相同，除非当前正在生效临时焦点更改。
    |'
- en: '| focusedWindow | The window that is or that contains the focus owner. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| focusedWindow | 具有焦点所有者的窗口。 |'
- en: '| activeWindow | The component must always be either a `Frame` or a `Dialog`.
    The active window is either the focused window, or the first frame or dialog-box
    that is an owner of the focused window. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| activeWindow | 该组件必须始终是`Frame`或`Dialog`。活动窗口要么是焦点窗口，要么是焦点窗口的第一个框架或对话框的所有者。
    |'
- en: '| defaultFocusTraversalPolicy | The default focus traversal policy, which can
    be set by the `setFocusTraversalPolicy` method of the `Container` class. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| defaultFocusTraversalPolicy | 默认的焦点遍历策略，可以通过`Container`类的`setFocusTraversalPolicy`方法设置。
    |'
- en: '| forwardDefaultFocusTraversalKeys | The set of default focus keys for a forward
    traversal. For multi-line text components, these keys default to Control-Tab.
    For all other components, these keys default to Tab and Control-Tab. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| forwardDefaultFocusTraversalKeys | 正向遍历的默认焦点键集。对于多行文本组件，默认为Control-Tab。对于所有其他组件，默认为Tab和Control-Tab。
    |'
- en: '| backwardDefaultFocusTraversalKeys | The set of default focus keys for a backward
    traversal. For multi-line text components these keys default to Control-Shift-Tab.
    For all other components these keys default to Shift-Tab and Control-Shift-Tab.
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| backwardDefaultFocusTraversalKeys | 后向遍历的默认焦点键集。对于多行文本组件，默认为Control-Shift-Tab。对于所有其他组件，默认为Shift-Tab和Control-Shift-Tab。
    |'
- en: '| upCycleDefaultFocusTraversalKeys | The set of default focus keys for an up
    cycle. These keys are null, by default, for Swing components. If you set these
    keys on the `KeyboardFocusManager`, or if you set the `downCycleFocusTraversalKeys`
    on a focus cycle root, you must also invoke the [`setImplicitDownCycleTraversal(false)`](https://docs.oracle.com/javase/8/docs/api/javax/swing/SortingFocusTraversalPolicy.html#setImplicitDownCycleTraversal-boolean-)
    method on the focus traversal policy. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| upCycleDefaultFocusTraversalKeys | 上行循环的默认焦点键集。对于 Swing 组件，默认情况下这些键为 null。如果您在`KeyboardFocusManager`上设置了这些键，或者在焦点循环根上设置了`downCycleFocusTraversalKeys`，则还必须在焦点遍历策略上调用[`setImplicitDownCycleTraversal(false)`](https://docs.oracle.com/javase/8/docs/api/javax/swing/SortingFocusTraversalPolicy.html#setImplicitDownCycleTraversal-boolean-)方法。
    |'
- en: '| downCycleDefaultFocusTraversalKeys | The set of default focus keys for a
    down cycle. These keys are null, by default, for Swing components. If you set
    these keys on the `KeyboardFocusManager`, or if you set the `upCycleFocusTraversalKeys`
    on a focus cycle root, you must also invoke the [`setImplicitDownCycleTraversal(false)`](https://docs.oracle.com/javase/8/docs/api/javax/swing/SortingFocusTraversalPolicy.html#setImplicitDownCycleTraversal-boolean-)
    method on the focus traversal policy. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| downCycleDefaultFocusTraversalKeys | 下一个循环的默认焦点键集。这些键在Swing组件中默认为null。如果您在`KeyboardFocusManager`上设置了这些键，或者在焦点循环根上设置了`upCycleFocusTraversalKeys`，您还必须在焦点遍历策略上调用[`setImplicitDownCycleTraversal(false)`](https://docs.oracle.com/javase/8/docs/api/javax/swing/SortingFocusTraversalPolicy.html#setImplicitDownCycleTraversal-boolean-)方法。
    |'
- en: '| currentFocusCycleRoot | The container that is the current focus cycle root.
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| currentFocusCycleRoot | 当前焦点循环根容器。 |'
- en: Examples that Use Focus
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用焦点的示例
- en: 'The following table lists examples that manipulate the focus:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了操纵焦点的示例：
- en: '| Example | Where Described | Notes |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 描述位置 | 注释 |'
- en: '| [`FocusConceptsDemo`](../examples/misc/index.html#FocusConceptsDemo) | This
    section | Demonstrates basic default focus behavior. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| [`FocusConceptsDemo`](../examples/misc/index.html#FocusConceptsDemo) | 本节
    | 演示基本的默认焦点行为。 |'
- en: '| [`FocusTraversalDemo`](../examples/misc/index.html#FocusTraversalDemo) |
    This section | Demonstrates how to override the default focus order. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| [`FocusTraversalDemo`](../examples/misc/index.html#FocusTraversalDemo) |
    本节 | 演示如何覆盖默认的焦点顺序。 |'
- en: '| [`TrackFocusDemo`](../examples/misc/index.html#TrackFocusDemo) | This section
    | Demonstrates how to use a `PropertyChangeListener` to track the focus owner.
    Also implements a custom focusable component. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| [`TrackFocusDemo`](../examples/misc/index.html#TrackFocusDemo) | 本节 | 演示如何使用`PropertyChangeListener`来跟踪焦点所有者。还实现了一个自定义的可聚焦组件。
    |'
- en: '| [`InputVerificationDemo`](../examples/misc/index.html#InputVerificationDemo)
    | This section | Demonstrates how to implement an `InputVerifier` to validate
    user input. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| [`InputVerificationDemo`](../examples/misc/index.html#InputVerificationDemo)
    | 本节 | 演示如何实现一个`InputVerifier`来验证用户输入。 |'
- en: '| [`InputVerificationDialogDemo`](../examples/misc/index.html#InputVerificationDialogDemo)
    | This section | Demonstrates how to implement an `InputVerifier` that puts up
    a dialog-box when user input is invalid. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| [`InputVerificationDialogDemo`](../examples/misc/index.html#InputVerificationDialogDemo)
    | 本节 | 演示如何实现一个`InputVerifier`，当用户输入无效时弹出对话框。 |'
- en: '| [`FocusEventDemo`](../examples/events/index.html#FocusEventDemo) | [How to
    Write a Focus Listener](../events/focuslistener.html) | Reports all focus events
    that occur on several components to demonstrate the circumstances under which
    focus events are fired. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| [`FocusEventDemo`](../examples/events/index.html#FocusEventDemo) | [如何编写焦点监听器](../events/focuslistener.html)
    | 报告发生在几个组件上的所有焦点事件，以展示焦点事件触发的情况。 |'
