- en: Working with Bidirectional Text
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理双向文本
- en: 原文：[https://docs.oracle.com/javase/tutorial/2d/text/textlayoutbidirectionaltext.html](https://docs.oracle.com/javase/tutorial/2d/text/textlayoutbidirectionaltext.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 译文：[https://docs.oracle.com/javase/tutorial/2d/text/textlayoutbidirectionaltext.html](https://docs.oracle.com/javase/tutorial/2d/text/textlayoutbidirectionaltext.html)
- en: 'This section discusses how to work with bidirectional text with classes in
    the [`java.awt`](https://docs.oracle.com/javase/8/docs/api/java/awt/package-summary.html)
    and [`java.awt.font`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/package-summary.html)
    packages. These classes let you draw styled text in any language or script supported
    by The Unicode Standard: a global character coding system for handling diverse
    modern, classical, and historical languages. When drawing text, the direction
    the text is read must be taken into account so that all words in the string display
    correctly. These classes maintain the direction of the text and correctly draws
    it no matter if the string runs left-to-right, right-to-left, or both (bidirectional).
    Bidirectional text presents interesting problems for correctly positioning carets,
    accurately locating selections, and correctly displaying multiple lines. Also
    bidirectional and right-to-left text present similar problems for moving the caret
    in the correct direction in response to right and left arrow key presses.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分讨论如何使用[`java.awt`](https://docs.oracle.com/javase/8/docs/api/java/awt/package-summary.html)和[`java.awt.font`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/package-summary.html)包中的类处理双向文本。这些类允许您以任何语言或脚本绘制样式化文本，这些语言或脚本受到Unicode标准的支持：这是一个全球字符编码系统，用于处理各种现代、古典和历史语言。在绘制文本时，必须考虑文本的阅读方向，以便字符串中的所有单词都能正确显示。这些类维护文本的方向，并正确绘制它，无论字符串是从左到右、从右到左还是双向运行。双向文本对于正确定位插入符、准确定位选择以及正确显示多行文本提出了有趣的问题。另外，双向和从右到左的文本对于根据右箭头和左箭头键的按压正确移动插入符也存在类似问题。
- en: 'The following topics are covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下列主题包括：
- en: '[Ordering Text](#ordering_text)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文本排序](#ordering_text)'
- en: '[Manipulating Bidirectional Text](#manipulating_bidirectional_text)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[操作双向文本](#manipulating_bidirectional_text)'
- en: '[Displaying Carets](#displaying_carets)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[显示插入符](#displaying_carets)'
- en: '[Moving Carets](#moving_carets)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[移动插入符](#moving_carets)'
- en: '[Hit Testing](#hit_testing)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[点击测试](#hit_testing)'
- en: '[Highlighting Selections](#highlighting_selections)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[突出显示选择](#highlighting_selections)'
- en: '[Performing Text Layout in a Java Application](#performing_text_layout_in_a_java_application)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在Java应用程序中执行文本布局](#performing_text_layout_in_a_java_application)'
- en: '[Managing Text Layout with the TextLayout Class](#managing_text_layout)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类管理文本布局](#managing_text_layout)'
- en: '[Laying Out Text with the TextLayout Class](#laying_out_text)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类布局文本](#laying_out_text)'
- en: '[Displaying Dual Carets with the TextLayout Class](#displaying_dual_carets)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类显示双插入符](#displaying_dual_carets)'
- en: '[Moving the Caret with the TextLayout Class](#moving_the_caret)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类移动插入符](#moving_the_caret)'
- en: '[Hit Testing with the TextLayout Class](#textlayout_hit_testing)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类进行点击测试](#textlayout_hit_testing)'
- en: '[Highlighting Selections with the TextLayout Class](#textlayout_highlighting_selections)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类突出显示选择](#textlayout_highlighting_selections)'
- en: If you plan to work with Swing components see [Working with Bidirectional Text
    with the JTextComponent Class](../../i18n/text/bidi.html) and [Using Text Components](../../uiswing/components/text.html)
    for more information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划使用Swing组件，请参阅[使用JTextComponent类处理双向文本](../../i18n/text/bidi.html)和[使用文本组件](../../uiswing/components/text.html)获取更多信息。
- en: Ordering Text
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本排序
- en: Java SE stores text in memory in logical order, which is the order in which
    characters and words are read and written. The logical order is not necessarily
    the same as the visual order, which is the order in which the corresponding glyphs
    are displayed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE在内存中以逻辑顺序存储文本，这是字符和单词读取和写入的顺序。逻辑顺序不一定与视觉顺序相同，后者是显示相应字形的顺序。
- en: A writing system' visual order must be maintained in bidirectional text even
    when languages are mixed together. This is illustrated in the following figure,
    which displays an Arabic phrase embedded in an English sentence.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使混合使用多种语言，双向文本中必须保持书写系统的视觉顺序。下图展示了一个嵌入在英语句子中的阿拉伯短语。
- en: '**Note:** In this and subsequent examples, Arabic and Hebrew text is represented
    by upper case letters and spaces are represented by underscores. Each illustration
    contains two parts: a representation of the characters stored in memory (the characters
    in logical order) followed by a representation of how those characters are displayed
    (the characters in visual order). The numbers below the character boxes indicate
    the insertion offsets.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 在这个和后续的示例中，阿拉伯语和希伯来语文本由大写字母表示，空格由下划线表示。每个示例包含两部分：存储在内存中的字符表示（逻辑顺序的字符）后跟这些字符如何显示的表示（视觉顺序的字符）。字符框下面的数字表示插入偏移量。'
- en: '![Arabic phrase embedded in an English sentence](../Images/cb79873f07af89c5c06419ac941977f3.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入在英语句子中的阿拉伯短语](../Images/cb79873f07af89c5c06419ac941977f3.png)'
- en: Even though they are part of an English sentence, the Arabic words are displayed
    in the Arabic script order, right-to-left. Because the italicized Arabic word
    is logically after the Arabic in plain text, it is visually to the left of the
    plain text.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们是英语句子的一部分，但阿拉伯语单词以阿拉伯语书写顺序从右到左显示。因为斜体的阿拉伯语单词在逻辑上位于普通文本的阿拉伯语单词之后，所以在视觉上位于普通文本的左侧。
- en: When a line with a mixture of left-to-right and right-to-left text is displayed,
    the *base direction* is significant. The base direction is the script order of
    the predominant writing system. For example, if the text is primarily English
    with some embedded Arabic, then the base direction is left-to-right. If the text
    is primarily Arabic with some embedded English or numbers, then the base direction
    is right-to-left.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示混合左到右和右到左文本的行时，*基本方向*很重要。基本方向是主要书写系统的书写顺序。例如，如果文本主要是英语并带有一些嵌入的阿拉伯语，则基本方向是从左到右。如果文本主要是阿拉伯语并带有一些嵌入的英语或数字，则基本方向是从右到左。
- en: 'The base direction determines the order in which segments of text with a common
    direction are displayed. In the example shown in the previous figure, the base
    direction is left-to-right. There are three directional runs in this example:
    the English text at the beginning of the sentence runs left to right, the Arabic
    text runs right to left, and the period runs left to right.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基本方向确定具有共同方向的文本段的显示顺序。在前面图中显示的示例中，基本方向是从左到右。在这个示例中有三个方向性运行：句子开头的英语文本从左到右运行，阿拉伯文本从右到左运行，句号从左到右运行。
- en: Graphics are often embedded in the flow of text. These inline graphics behave
    like glyphs in terms of how they affect the text flow and line wrapping. Such
    inline graphics need to be positioned using the same bidirectional layout algorithm
    so that they appear in the proper location in the flow of characters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图形通常嵌入在文本流中。这些内联图形在影响文本流和换行方式方面类似于字形。这样的内联图形需要使用相同的双向布局算法定位，以便它们出现在字符流的适当位置。
- en: Java SE uses the [Unicode Bidirectional Algorithm](http://unicode.org/reports/tr9/),
    which is an algorithm that is used to order glyphs within a line, thereby determining
    the directionality of bidirectional texts. In most cases, you do not need to include
    any additional information in order for this algorithm to obtain the correct display
    ordering.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE使用[Unicode双向算法](http://unicode.org/reports/tr9/)，这是一种用于在一行内对字形进行排序的算法，从而确定双向文本的方向性。在大多数情况下，您无需包含任何额外信息，以便该算法获取正确的显示顺序。
- en: Manipulating Bidirectional Text
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵双向文本
- en: 'To allow the user to edit bidirectional text, you must be able to do the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户编辑双向文本，您必须能够执行以下操作：
- en: '[Displaying Carets](#displaying_carets)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[显示插入符](#displaying_carets)'
- en: '[Moving Carets](#moving_carets)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[移动插入符](#moving_carets)'
- en: '[Hit Testing](#hit_testing)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[点击测试](#hit_testing)'
- en: '[Highlighting Selections](#highlighting_selections)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[突出显示选择](#highlighting_selections)'
- en: Displaying Carets
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示插入符
- en: In editable text, a *caret* is used to graphically represent the current insertion
    point, the position in the text where new characters will be inserted. Typically,
    a caret is shown as a blinking vertical bar between two glyphs. New characters
    are inserted and displayed at the caret's location.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在可编辑文本中，*插入符*用于图形化表示当前插入点，即文本中新字符将被插入的位置。通常，插入符显示为两个字形之间闪烁的垂直条。新字符被插入并显示在插入符的位置。
- en: Calculating the caret position can be complicated, particularly for bidirectional
    text. Insertion offsets on directional boundaries have two possible caret positions
    because the two glyphs that correspond to the character offset are not displayed
    adjacent to one another. This is illustrated in the following figure. In this
    figure, the carets are shown as square brackets to indicate the glyph to which
    the caret corresponds.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '计算插入符位置可能会很复杂，特别是对于双向文本。在方向边界上的插入偏移量有两个可能的插入符位置，因为对应于字符偏移量的两个字形不会相邻显示。如下图所示。在此图中，插入符显示为方括号，表示插入符对应的字形。 '
- en: '![Dual carets](../Images/9151e5f35105d66dbdf6214007279f42.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![双插入符](../Images/9151e5f35105d66dbdf6214007279f42.png)'
- en: Character offset 8 corresponds to the location after the underscore and before
    the *A*. If the user enters an Arabic character, its glyph is displayed to the
    right of (before) the *A*; if the user enters an English character, its glyph
    is displayed to the right of (after) the underscore.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字符偏移量 8 对应于下划线后和*A*之前的位置。如果用户输入阿拉伯字符，其字形将显示在*A*的右侧；如果用户输入英文字符，其字形将显示在下划线的右侧。
- en: To handle this situation, some systems display dual carets, a strong (primary)
    caret and a weak (secondary) caret. The strong caret indicates where an inserted
    character will be displayed when that character's direction is the same as the
    base direction of the text. The weak caret shows where an inserted character will
    be displayed when the character's direction is the opposite of the base direction
    [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    automatically supports dual carets.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况，一些系统显示双插入符，一个强（主要）插入符和一个弱（次要）插入符。强插入符指示插入的字符的方向与文本基础方向相同时将显示在何处。弱插入符显示插入的字符的方向与基础方向相反时将显示在何处[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)自动支持双插入符。
- en: 'When you''re working with bidirectional text, you can''t simply add the widths
    of the glyphs before a character offset to calculate the caret position. If you
    did, the caret would be drawn in the wrong place, as shown in the following figure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理双向文本时，不能简单地将字符偏移量之前的字形宽度相加以计算插入符位置。如果这样做，插入符将被绘制在错误的位置，如下图所示：
- en: '![Caret drawn incorrectly](../Images/883c6741c87ff73b0f1eae5bb0d0550d.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![插入符绘制错误](../Images/883c6741c87ff73b0f1eae5bb0d0550d.png)'
- en: For the caret to be properly positioned, the widths of the glyphs to the left
    of the offset need to be added and the current context taken into account. Unless
    the context is taken into account, the glyph metrics will not necessarily match
    the display. (The context can affect which glyphs are used.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确定位插入符，需要将偏移量左侧的字形宽度相加，并考虑当前上下文。除非考虑上下文，否则字形度量可能不会与显示匹配。（上下文可能会影响使用哪些字形。）
- en: Moving Carets
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动插入符
- en: 'All text editors allow the user to move the caret with the arrow keys. Users
    expect the caret to move in the direction of the pressed arrow key. In left-to-right
    text, moving the insertion offset is simple: the right arrow key increases the
    insertion offset by one and the left arrow key decreases it by one. In bidirectional
    text or in text with ligatures, this behavior would cause the caret to jump across
    glyphs at direction boundaries and move in the reverse direction within different
    directional runs.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文本编辑器都允许用户使用箭头键移动插入符。用户期望插入符沿按下的箭头键方向移动。在从左到右的文本中，移动插入偏移量很简单：右箭头键将插入偏移量增加一，左箭头键将其减少一。在双向文本或带有连字的文本中，此行为会导致插入符跨越方向边界的字形并在不同方向运行内部反向移动。
- en: To move the caret smoothly through bidirectional text, you need to take into
    account the direction of the text runs. You can't simply increment the insertion
    offset when the right arrow key is pressed and decrement it when the left arrow
    key is pressed. If the current insertion offset is within a run of right-to-left
    characters, the right arrow key should decrease the insertion offset, and the
    left arrow key should increase it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在双向文本中平滑移动插入符，需要考虑文本运行的方向。当按下右箭头键时不能简单地增加插入偏移量，当按下左箭头键时减少它。如果当前插入偏移量位于从右到左字符的运行内，右箭头键应减少插入偏移量，左箭头键应增加它。
- en: Moving the caret across a directional boundary is even more complicated. The
    following figure illustrates what happens when a directional boundary is crossed
    when the user is navigating with the arrow key. Stepping three positions to the
    right in the displayed text corresponds to moving to the character offsets 7,
    19, then 18.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨越方向边界时移动插入符更加复杂。下图说明了当用户使用箭头键导航时，当穿越方向边界时会发生什么。在显示的文本中向右移动三个位置对应于移动到字符偏移7、19，然后是18。
- en: '![Caret movement](../Images/2b600043baeb77a22daf87dcb12fd14e.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![插入符移动](../Images/2b600043baeb77a22daf87dcb12fd14e.png)'
- en: Certain glyphs should never have a caret between them; instead, the caret should
    move as though the glyphs represented a single character. For example, there should
    never be a caret between an *o* and an umlaut if they are represented by two separate
    characters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 某些字形之间永远不应该有插入符；相反，插入符应该移动得像这些字形代表一个单一字符一样。例如，如果一个 *o* 和一个变音符由两个单独的字符表示，那么它们之间永远不应该有插入符。
- en: The [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    class provides methods ( [`getNextRightHit`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getNextRightHit-int-)
    and [`getNextLeftHit`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getNextLeftHit-int-))
    that enable you to easily move the caret smoothly through bidirectional text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    类提供了方法（[`getNextRightHit`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getNextRightHit-int-)
    和 [`getNextLeftHit`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getNextLeftHit-int-)），使您能够轻松地在双向文本中平滑地移动插入符。'
- en: Hit Testing
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命中测试
- en: Often, a location in device space must be converted to a text offset. For example,
    when a user clicks the mouse on selectable text, the location of the mouse is
    converted to a text offset and used as one end of the selection range. Logically,
    this is the inverse of positioning a caret.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设备空间中的位置必须转换为文本偏移量。例如，当用户在可选择文本上单击鼠标时，鼠标位置将转换为文本偏移量，并用作选择范围的一端。从逻辑上讲，这是放置插入符的逆过程。
- en: 'When you''re working with bidirectional text, a single visual location in the
    display can correspond to two different offsets in the source text, as shown in
    the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理双向文本时，显示中的单个视觉位置可以对应源文本中的两个不同偏移量，如下图所示：
- en: '![Hit testing bidirectional text](../Images/0c18a117465bc036faee3404d01e160e.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![命中测试双向文本](../Images/0c18a117465bc036faee3404d01e160e.png)'
- en: Because a single visual location can correspond to two different offsets, hit
    testing bidirectional text isn't just a matter of measuring glyph widths until
    the glyph at the correct location is found and then mapping that position back
    to a character offset. Detecting the side that the hit was on helps distinguish
    between the two alternatives.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为单个视觉位置可以对应两个不同的偏移量，所以命中测试双向文本不仅仅是测量字形宽度直到找到正确位置的字形，然后将该位置映射回字符偏移量。检测命中位置所在的一侧有助于区分这两种选择。
- en: You can perform hit testing using [`TextLayout.hitTestChar`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#hitTestChar-float-float-).
    Hit information is encapsulated in a [`TextHitInfo`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextHitInfo.html)
    object and includes information about the side that the hit was on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 [`TextLayout.hitTestChar`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#hitTestChar-float-float-)
    进行命中测试。命中信息封装在 [`TextHitInfo`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextHitInfo.html)
    对象中，并包括有关命中位置所在一侧的信息。
- en: Highlighting Selections
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 突出显示选择
- en: A selected range of characters is represented graphically by a highlight region,
    an area in which glyphs are displayed with inverse video or against a different
    background color.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一段选定的字符范围通过一个高亮区域图形化表示，其中字形以反色或不同背景颜色显示。
- en: Highlight regions, like carets, are more complicated for bidirectional text
    than for unidirectional text. In bidirectional text, a contiguous range of characters
    might not have a contiguous highlight region when displayed. Conversely, a highlight
    region showing a visually contiguous range of glyphs might not correspond to a
    single, contiguous range of characters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮区域，就像插入符一样，在双向文本中比单向文本更复杂。在双向文本中，一段连续的字符范围在显示时可能没有连续的高亮区域。相反，显示为视觉上连续的一系列字形的高亮区域可能不对应单一、连续的字符范围。
- en: 'This results in two strategies for highlighting selections in bidirectional
    text:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致双向文本中突出选择的两种策略：
- en: '*Logical highlighting*: With logical highlighting, the selected characters
    are always contiguous in the text model, and the highlight region is allowed to
    be discontiguous. The following is an example of logical highlighting:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑高亮*：使用逻辑高亮，所选字符在文本模型中始终是连续的，而高亮区域允许是不连续的。以下是逻辑高亮的示例：'
- en: '![Illustration of logical highlighting (contiguous characters)](../Images/9e592b6d7e76ccbdac05b9d2207e30ee.png)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![逻辑高亮示例（连续字符）](../Images/9e592b6d7e76ccbdac05b9d2207e30ee.png)'
- en: '*Visual highlighting*: With visual highlighting, there might be more than one
    range of selected characters, but the highlight region is always contiguous. The
    following is an example of visual highlighting:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可视高亮*：使用可视高亮，可能会有多个选定字符范围，但高亮区域始终是连续的。以下是可视高亮的示例：'
- en: '![Illustration of visual highlighting (contiguous highlight region)](../Images/b9968b8b5e84c6c695459a8778694571.png)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![可视高亮示例（连续高亮区域）](../Images/b9968b8b5e84c6c695459a8778694571.png)'
- en: Logical highlighting is simpler to implement, since the selected characters
    are always contiguous in the text.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑高亮更容易实现，因为所选字符在文本中始终是连续的。
- en: 'The sample [``SelectionSample.java``](examples/SelectionSample.java) demonstrates
    logical highlighting:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例[`SelectionSample.java`](examples/SelectionSample.java)演示了逻辑高亮：
- en: '![Selection Sample; demonstration of logical highlighting](../Images/e88eed1bd0b81ce5fe1b2dd7439e2210.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![选择示例；逻辑高亮演示](../Images/e88eed1bd0b81ce5fe1b2dd7439e2210.png)'
- en: Performing Text Layout in a Java Application
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java应用程序中执行文本布局
- en: 'Depending on which Java APIs you use, you can have as little or as much control
    over text layout as you need:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的Java API，您可以根据需要对文本布局进行精细或粗略的控制：
- en: If you just want to display a block of text or need an editable text control,
    you can use [`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html),
    which will perform the text layout for you. [`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html)
    is designed to handle the needs of most international applications and supports
    bidirectional text For more information about [`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html),
    see [Working with Bidirectional Text with the JTextComponent Class](../../i18n/text/bidi.html)
    and [Using Text Components](../../uiswing/components/text.html) for more information.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只想显示一块文本或需要一个可编辑的文本控件，您可以使用[`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html)，它将为您执行文本布局。[`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html)旨在处理大多数国际应用程序的需求，并支持双向文本。有关[`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html)的更多信息，请参见[使用JTextComponent类处理双向文本](../../i18n/text/bidi.html)和[使用文本组件](../../uiswing/components/text.html)。
- en: If you want to display a simple text string, you can call the method [`Graphics2D.drawString`](https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html#drawString-java.text.AttributedCharacterIterator-int-int-)
    and let Java 2D lay out the string for you. You can also use [`Graphics2D.drawString`](https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html#drawString-java.text.AttributedCharacterIterator-int-int-)
    to render styled strings and strings that contain bidirectional text. For more
    information about rendering text through [`Graphics2D`](https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html),
    see [Working with Text APIs](index.html).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想显示一个简单的文本字符串，您可以调用方法[`Graphics2D.drawString`](https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html#drawString-java.text.AttributedCharacterIterator-int-int-)，让Java
    2D为您布局字符串。您还可以使用[`Graphics2D.drawString`](https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html#drawString-java.text.AttributedCharacterIterator-int-int-)来呈现带样式的字符串和包含双向文本的字符串。有关通过[`Graphics2D`](https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html)呈现文本的更多信息，请参见[使用文本API](index.html)。
- en: If you want to implement your own text editing routines, you can use [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    to manage text layout, highlighting, and hit detection. The facilities provided
    by [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    handle most common cases, including text strings with mixed fonts, mixed languages,
    and bidirectional text. For more information about using TextLayout, see [Managing
    Text Layout](#managing_text_layout).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想实现自己的文本编辑例程，可以使用 [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    来管理文本布局、高亮显示和点击检测。[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    提供的功能处理了大多数常见情况，包括具有混合字体、混合语言和双向文本的文本字符串。有关使用 TextLayout 的更多信息，请参见[管理文本布局](#managing_text_layout)。
- en: If you want total control over how text is shaped and positioned, you can construct
    your own [`GlyphVector`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/GlyphVector.html)
    instances using the [`Font`](https://docs.oracle.com/javase/8/docs/api/java/awt/Font.html)
    class and then render them through the [`Graphics2D`](https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html)
    class.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想完全控制文本的形状和位置，可以使用 [`Font`](https://docs.oracle.com/javase/8/docs/api/java/awt/Font.html)
    类构建自己的 [`GlyphVector`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/GlyphVector.html)
    实例，然后通过 [`Graphics2D`](https://docs.oracle.com/javase/8/docs/api/java/awt/Graphics2D.html)
    类进行渲染。
- en: Generally, you do not need to perform text layout operations yourself. For most
    applications, [`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html)
    is the best solution for displaying static and editable text. However, [`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html)
    does not support the display of dual carets or discontiguous selections in bidirectional
    text. If your application requires these features, or you prefer to implement
    your own text editing routines, you can use the Java 2D text layout APIs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不需要自己执行文本布局操作。对于大多数应用程序，[`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html)
    是显示静态和可编辑文本的最佳解决方案。但是，[`JTextComponent`](https://docs.oracle.com/javase/8/docs/api/javax/swing/text/JTextComponent.html)
    不支持双插入符或双向文本中的不连续选择的显示。如果您的应用程序需要这些功能，或者您更喜欢实现自己的文本编辑例程，可以使用 Java 2D 文本布局 API。
- en: Managing Text Layout with the TextLayout Class
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TextLayout 类管理文本布局
- en: The [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    class supports text that contains multiple styles and characters from different
    writing systems, including Arabic and Hebrew. (Arabic and Hebrew are particularly
    difficult to display because you must reshape and reorder the text to achieve
    an acceptable representation.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    类支持包含多种样式和来自不同书写系统（包括阿拉伯文和希伯来文）的字符的文本。（阿拉伯文和希伯来文特别难以显示，因为您必须重新排列和重新排序文本以获得可接受的表示。）'
- en: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    simplifies the process of displaying and measuring text even if you are working
    with English-only text. By using [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html),
    you can achieve high-quality typography with no extra effort.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您只处理英文文本，[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    也简化了显示和测量文本的过程。通过使用 [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)，您可以在不费额外努力的情况下实现高质量的排版。
- en: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    is designed so that there is no significant performance impact when it is used
    to display simple, unidirectional text. There is some additional processing overhead
    when [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    is used to display Arabic or Hebrew text. However, it''s typically on the order
    of microseconds per character and is dominated by the execution of normal drawing
    code.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    被设计为在显示简单的单向文本时不会产生显著的性能影响。当使用 [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    显示阿拉伯文或希伯来文时，会有一些额外的处理开销。但是，这通常是每个字符的微秒数量级，并且被正常绘图代码的执行所主导。'
- en: 'The [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    class manages the positioning and ordering of glyphs for you. You can use [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    to do the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    类为您管理字形的定位和排序。您可以使用[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    来执行以下操作：'
- en: '[Laying Out Text with the TextLayout Class](#laying_out_text)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类进行文本布局](#laying_out_text)'
- en: '[Displaying Dual Carets with the TextLayout Class](#displaying_dual_carets)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类显示双光标](#displaying_dual_carets)'
- en: '[Moving the Caret with the TextLayout Class](#moving_the_caret)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类移动光标](#moving_the_caret)'
- en: '[Hit Testing with the TextLayout Class](#textlayout_hit_testing)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类进行点击测试](#textlayout_hit_testing)'
- en: '[Highlighting Selections with the TextLayout Class](#textlayout_highlighting_selections)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用TextLayout类突出显示选择内容](#textlayout_highlighting_selections)'
- en: Laying Out Text with the TextLayout Class
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TextLayout类进行文本布局
- en: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    automatically lays out text, including bidirectional text, with the correct shaping
    and ordering. To correctly shape and order the glyphs representing a line of text,
    [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    must know the full context of the text:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    自动布局文本，包括双向文本，具有正确的形状和顺序。为了正确形状和排序表示一行文本的字形，[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    必须了解文本的完整上下文：'
- en: If the text fits on a single line, such as a single-word label for a button
    or a line in a dialog box, you can construct a [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    directly from the text.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本适合单行，例如按钮的单词标签或对话框中的一行文本，您可以直接从文本构造一个[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)。
- en: If you have more text than can fit on a single line or want to break text on
    a single line into tabbed segments, you cannot construct a [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    directly. You must use a [`LineBreakMeasurer`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/LineBreakMeasurer.html)
    to provide sufficient context. See [Drawing Multiple Lines of Text](drawmulstring.html)
    for more information.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有更多文本无法适合单行或想要在单行文本上分隔制表符段，您不能直接构造一个[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)。您必须使用[`LineBreakMeasurer`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/LineBreakMeasurer.html)
    提供足够的上下文。有关更多信息，请参见[绘制多行文本](drawmulstring.html)。
- en: The base direction of the text is normally set by an attribute (style) on the
    text. If that attribute is missing, [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    follows the Unicode bidirectional algorithm and derives the base direction from
    the initial characters in the paragraph.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的基本方向通常由文本上的属性（样式）设置。如果该属性缺失，[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    将遵循Unicode双向算法，并从段落中的初始字符推导基本方向。
- en: Displaying Dual Carets with the TextLayout Class
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TextLayout类显示双光标
- en: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    maintains caret information such as the caret [`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html),
    position, and angle. You can use this information to easily display carets in
    both unidirectional and bidirectional text. When you''re drawing carets for bidirectional
    text, using [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    ensures that the carets will be positioned correctly.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    保留光标信息，如光标[`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)、位置和角度。您可以使用此信息轻松地在单向和双向文本中显示光标。在为双向文本绘制光标时，使用[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    可确保光标位置正确。'
- en: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    provides default caret `Shapes` and automatically supports dual carets. For italic
    and oblique glyphs, [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    produces angled carets, as shown in the following figure. These caret positions
    are also used as the boundaries between glyphs for highlighting and hit testing,
    which helps produce a consistent user experience.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)提供默认插入符`Shapes`并自动支持双插入符。对于斜体和倾斜字形，[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)会产生倾斜插入符，如下图所示。这些插入符位置也用作高亮和命中测试之间的字形边界，有助于产生一致的用户体验。'
- en: '![Angled carets](../Images/01f1644bdafa8e4c9134e1867ef0f4ea.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![倾斜插入符](../Images/01f1644bdafa8e4c9134e1867ef0f4ea.png)'
- en: 'Given an insertion offset, the [`getCaretShapes`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getCaretShapes-int-)
    method returns a two-element array of [`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)
    objects: element 0 contains the strong caret and element 1 contains the weak caret,
    if one exists. To display dual carets, you simply draw both caret [`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)
    objects; the carets will be automatically be rendered in the correct positions.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 给定插入偏移量，[`getCaretShapes`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getCaretShapes-int-)方法返回一个包含两个[`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)对象的数组：元素0包含强插入符，元素1包含弱插入符（如果存在）。要显示双插入符，只需绘制两个插入符[`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)对象；插入符将自动呈现在正确的位置。
- en: If you want to use custom carets, you can retrieve the position and angle of
    the carets from the [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    and draw them yourself.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用自定义插入符，可以从[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)中检索插入符的位置和角度，并自行绘制它们。
- en: The sample [``HitTestSample.java``](examples/HitTestSample.java) demonstrates
    dual carets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 示例[`HitTestSample.java`](examples/HitTestSample.java)演示了双插入符。
- en: 'A click on the *o* on the side of the *o* towards the Hebrew text records that
    the end user clicked after the *o*, which is part of the English text. This positions
    the weak (black) caret next to the *o* and the strong caret (red) in front of
    the *H*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 点击希伯来文本旁边的*o*会记录用户在*o*之后点击的位置，这部分属于英文文本。这将使弱（黑色）插入符位于*o*旁边，而强插入符（红色）位于*H*之前：
- en: '![Hit Test Sample, clicked the ''o'' on the side towards the Hebrew text](../Images/a77278839b55763ccb169d33e878f78b.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![点击希伯来文本旁边的''o''的命中测试示例](../Images/a77278839b55763ccb169d33e878f78b.png)'
- en: 'A click on the space to the right of the *o* records that the end user clicked
    the space, which is part of the Hebrew text. This positions the strong (red) caret
    next to the *o* and the weak caret (black) in front of the *H*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 点击*o*右侧的空格会记录用户点击了空格，这部分属于希伯来文本。这将使强（红色）插入符位于*o*旁边，而弱插入符（黑色）位于*H*之前：
- en: '![Hit Test Sample, clicked the space to the right of the ''o''](../Images/e656d8548d9dc6f3466d5bfeb33310ba.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![点击''o''右侧的空格的命中测试示例](../Images/e656d8548d9dc6f3466d5bfeb33310ba.png)'
- en: Moving the Caret with the TextLayout Class
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TextLayout类移动插入符
- en: You can also use the [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    class to determine the resulting insertion offset when a user presses the left
    or right arrow key. Given a `TextHitInfo` object that represents the current insertion
    offset, the [`getNextRightHit`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getNextRightHit-java.awt.font.TextHitInfo-)
    method returns a [`TextHitInfo`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextHitInfo.html)
    object that represents the correct insertion offset if the right arrow key is
    pressed. The [`getNextLeftHit`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getNextLeftHit-java.awt.font.TextHitInfo-)
    method provides the same information for the left arrow key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)类确定用户按下左箭头或右箭头键时的插入偏移量。给定表示当前插入偏移量的`TextHitInfo`对象，[`getNextRightHit`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getNextRightHit-java.awt.font.TextHitInfo-)方法返回一个表示正确插入偏移量的[`TextHitInfo`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextHitInfo.html)对象，如果按下右箭头键。[`getNextLeftHit`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#getNextLeftHit-java.awt.font.TextHitInfo-)方法为左箭头键提供相同的信息。
- en: 'The following excerpt from the sample [``ArrowKeySample.java``](examples/ArrowKeySample.java)
    demonstrates how to determine the resulting insertion offset when a user presses
    the left or right arrow key:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 来自示例[``ArrowKeySample.java``](examples/ArrowKeySample.java)的以下摘录演示了确定用户按下左箭头或右箭头键时的插入偏移量的方法：
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Hit Testing with the TextLayout Class
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TextLayout类进行命中测试
- en: 'The [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    class provides a simple mechanism for hit testing text. The [`hitTextChar`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html#hitTestChar-float-float-)
    method takes *x* and *y* coordinates from the mouse as arguments and returns a
    [`TextHitInfo`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextHitInfo.html)
    object. The [`TextHitInfo`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextHitInfo.html)
    contains the insertion offset for the specified position and the side that the
    hit was on. The insertion offset is the offset closest to the hit: if the hit
    is past the end of the line, the offset at the end of the line is returned.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)类提供了一个简单的文本命中测试机制。`hitTextChar`方法以鼠标的*x*和*y*坐标作为参数，并返回一个[`TextHitInfo`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextHitInfo.html)对象。[`TextHitInfo`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextHitInfo.html)包含指定位置的插入偏移量和命中位置的侧面。插入偏移量是最接近命中位置的偏移量：如果命中位置超过行尾，将返回行尾的偏移量。'
- en: 'The following excerpt from [``HitTestSample.java``](examples/HitTestSample.java)
    retrieves the offset from a mouse click:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[``HitTestSample.java``](examples/HitTestSample.java)的以下摘录从鼠标点击中检索偏移量：
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Highlighting Selections with the TextLayout Class
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TextLayout类进行高亮选择
- en: You can get a [`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)
    that represents the highlight region from the [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html).
    [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    automatically takes the context into account when calculating the dimensions of
    the highlight region. [`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)
    supports both logical and visual highlighting.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)获取代表高亮区域的[`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)。在计算高亮区域的尺寸时，[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)会自动考虑上下文。[`TextLayout`](https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextLayout.html)支持逻辑和视觉高亮。
- en: 'The following excerpt from [``SelectionSample.java``](examples/SelectionSample.java)
    demonstrates one way to display highlighted text:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[``SelectionSample.java``](examples/SelectionSample.java)的以下摘录演示了显示高亮文本的一种方法：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The method `SelectionMouseListener.mousePressed` specifies the variable `anchorEnd`,
    which is the position in the text where the mouse was clicked. The method `SelectionMouseMotionListener.mouseDragged`
    specifies the variable `activeEnd`, which is the position in the text to where
    the mouse was dragged. The `paint` method retrieves a [`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)
    object that represents the selected text (the text between the positions `anchorEnd`
    and `activeEnd`). The `paint` method then fills the [`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)
    object with the highlight color.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`SelectionMouseListener.mousePressed`指定了变量`anchorEnd`，它是鼠标点击的文本位置。方法`SelectionMouseMotionListener.mouseDragged`指定了变量`activeEnd`，它是鼠标拖动到的文本位置。`paint`方法检索一个代表所选文本的[`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)对象（即`anchorEnd`和`activeEnd`位置之间的文本）。然后`paint`方法用高亮颜色填充[`Shape`](https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html)对象。
