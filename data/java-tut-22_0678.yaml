- en: Overview of the Sampled Package
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采样包概述
- en: 原文：[https://docs.oracle.com/javase/tutorial/sound/sampled-overview.html](https://docs.oracle.com/javase/tutorial/sound/sampled-overview.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.oracle.com/javase/tutorial/sound/sampled-overview.html](https://docs.oracle.com/javase/tutorial/sound/sampled-overview.html)
- en: The [`javax.sound.sampled`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/package-summary.html)
    package is fundamentally concerned with audio transport — in other words, the
    Java Sound API focuses on playback and capture. The central task that the Java
    Sound API addresses is how to move bytes of formatted audio data into and out
    of the system. This task involves opening audio input and output devices and managing
    buffers that get filled with real-time sound data. It can also involve mixing
    multiple streams of audio into one stream (whether for input or output). The transport
    of sound into or out of the system has to be correctly handled when the user requests
    that the flow of sound be started, paused, resumed, or stopped.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[`javax.sound.sampled`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/package-summary.html)
    包主要涉及音频传输 - 换句话说，Java Sound API 专注于播放和捕获。 Java Sound API 解决的核心任务是如何将格式化音频数据的字节移入和移出系统。
    这项任务涉及打开音频输入和输出设备以及管理填充实时音频数据的缓冲区。 它还可以涉及将多个音频流混合成一个流（无论是用于输入还是输出）。 当用户请求启动、暂停、恢复或停止声音流时，系统内部的声音传输必须得到正确处理。'
- en: To support this focus on basic audio input and output, the Java Sound API provides
    methods for converting between various audio data formats, and for reading and
    writing common types of sound files. However, it does not attempt to be a comprehensive
    sound-file toolkit. A particular implementation of the Java Sound API need not
    support an extensive set of file types or data format conversions. Third-party
    service providers can supply modules that "plug in" to an existing implementation
    to support additional file types and conversions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持对基本音频输入和输出的关注，Java Sound API 提供了在各种音频数据格式之间转换的方法，并且提供了读取和写入常见类型的声音文件的方法。
    但是，它并不试图成为一个全面的声音文件工具包。 Java Sound API 的特定实现不必支持广泛的文件类型或数据格式转换。 第三方服务提供商可以提供模块，这些模块可以“插入”到现有实现中，以支持额外的文件类型和转换。
- en: The Java Sound API can handle audio transport in both a streaming, buffered
    fashion and an in-memory, unbuffered fashion. "Streaming" is used here in a general
    sense to refer to real-time handling of audio bytes; it does not refer to the
    specific, well-known case of sending audio over the Internet in a certain format.
    In other words, a stream of audio is simply a continuous set of audio bytes that
    arrive more or less at the same rate that they are to be handled (played, recorded,
    etc.). Operations on the bytes commence before all the data has arrived. In the
    streaming model, particularly in the case of audio input rather than audio output,
    you do not necessarily know in advance how long the sound is and when it will
    finish arriving. You simply handle one buffer of audio data at a time, until the
    operation is halted. In the case of audio output (playback), you also need to
    buffer data if the sound you want to play is too large to fit in memory all at
    once. In other words, you deliver your audio bytes to the sound engine in chunks,
    and it takes care of playing each sample at the right time. Mechanisms are provided
    that make it easy to know how much data to deliver in each chunk.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java Sound API 可以以流式缓冲方式和内存中非缓冲方式处理音频传输。 这里所说的“流式”是指实时处理音频字节； 它并不是指以某种特定格式通过互联网发送音频的众所周知的情况。
    换句话说，音频流只是一组连续的音频字节，它们以更多或更少的相同速率到达，以便处理（播放、录制等）。 操作在所有数据到达之前开始。 在流式模型中，特别是在音频输入而不是音频输出的情况下，您不一定事先知道声音的持续时间以及何时会完成到达。
    您只需一次处理一个音频数据缓冲区，直到操作停止。 在音频输出（播放）的情况下，如果要播放的声音太大而无法一次性放入内存中，则还需要缓冲数据。 换句话说，您以块的形式将音频字节传递给声音引擎，它会在正确的时间播放每个样本。
    提供了机制，使得很容易知道每个块中要传递多少数据。
- en: The Java Sound API also permits unbuffered transport in the case of playback
    only, assuming you already have all the audio data at hand and it is not too large
    to fit in memory. In this situation, there is no need for the application program
    to buffer the audio, although the buffered, real-time approach is still available
    if desired. Instead, the entire sound can be preloaded at once into memory for
    subsequent playback. Because all the sound data is loaded in advance, playback
    can start immediately — for example, as soon as the user clicks a Start button.
    This can be an advantage compared to the buffered model, where the playback has
    to wait for the first buffer to fill. In addition, the in-memory, unbuffered model
    allows sounds to be easily looped (cycled) or set to arbitrary positions in the
    data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java Sound API还允许在仅播放的情况下进行无缓冲传输，假设您已经拥有所有音频数据并且数据量不太大以适应内存。在这种情况下，应用程序无需缓冲音频，尽管如果需要，仍然可以使用缓冲的实时方法。相反，整个声音可以一次性预加载到内存中以供后续播放。由于所有声音数据都是预先加载的，因此播放可以立即开始，例如，用户点击“开始”按钮时。与缓冲模型相比，这可能是一个优势，因为在缓冲填满之前，播放必须等待第一个缓冲区。此外，内存中的无缓冲模型允许轻松循环（循环）声音或将其设置为数据中的任意位置。
- en: 'To play or capture sound using the Java Sound API, you need at least three
    things: formatted audio data, a mixer, and a line. The following provides an overview
    of these concepts.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java Sound API播放或捕获声音时，您至少需要三样东西：格式化的音频数据，混音器和线路。以下是这些概念的概述。
- en: What is Formatted Audio Data?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是格式化音频数据？
- en: Formatted audio data refers to sound in any of a number of standard formats.
    The Java Sound API distinguishes between *data formats* and *file formats*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化的音频数据指的是任何一种标准格式的声音。Java Sound API区分*数据格式*和*文件格式*。
- en: Data Formats
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据格式
- en: A data format tells you how to interpret a series of bytes of "raw" sampled
    audio data, such as samples that have already been read from a sound file, or
    samples that have been captured from the microphone input. You might need to know,
    for example, how many bits constitute one sample (the representation of the shortest
    instant of sound), and similarly you might need to know the sound's sample rate
    (how fast the samples are supposed to follow one another). When setting up for
    playback or capture, you specify the data format of the sound you are capturing
    or playing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据格式告诉您如何解释一系列“原始”采样音频数据的字节，例如已从声音文件中读取的样本，或者已从麦克风输入捕获的样本。例如，您可能需要知道一个样本包含多少比特（表示声音的最短瞬间的表示），同样您可能需要知道声音的采样率（样本应该多快地跟随彼此）。在设置播放或捕获时，您指定正在捕获或播放的声音的数据格式。
- en: 'In the Java Sound API, a data format is represented by an [`AudioFormat`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioFormat.html)
    object, which includes the following attributes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Sound API中，数据格式由一个[`AudioFormat`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioFormat.html)对象表示，其中包括以下属性：
- en: Encoding technique, usually pulse code modulation (PCM)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码技术，通常是脉冲编码调制（PCM）
- en: Number of channels (1 for mono, 2 for stereo, etc.)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道数（单声道为1，立体声为2，等等）
- en: Sample rate (number of samples per second, per channel)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采样率（每秒每个通道的样本数）
- en: Number of bits per sample (per channel)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个样本（每个通道）的比特数
- en: Frame rate
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧率
- en: Frame size in bytes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每帧大小（以字节为单位）
- en: Byte order (big-endian or little-endian)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节顺序（大端或小端）
- en: PCM is one kind of encoding of the sound waveform. The Java Sound API includes
    two PCM encodings that use linear quantization of amplitude, and signed or unsigned
    integer values. Linear quantization means that the number stored in each sample
    is directly proportional (except for any distortion) to the original sound pressure
    at that instant—and similarly proportional to the displacement of a loudspeaker
    or eardrum that is vibrating with the sound at that instant. Compact discs, for
    example, use linear PCM-encoded sound. Mu-law encoding and a-law encoding are
    common nonlinear encodings that provide a more compressed version of the audio
    data; these encodings are typically used for telephony or recordings of speech.
    A nonlinear encoding maps the original sound's amplitude to the stored value using
    a nonlinear function, which can be designed to give more amplitude resolution
    to quiet sounds than to loud sounds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PCM是声波的一种编码方式。Java Sound API包括两种使用线性幅度量化的PCM编码，以及带符号或无符号整数值。线性量化意味着每个样本中存储的数字与该瞬间的原始声压（除了任何失真）成正比，类似地与振动声音的扬声器或鼓膜的位移成正比，该振动声音在该瞬间发生。例如，CD使用线性PCM编码的声音。
    mu-law编码和a-law编码是常见的非线性编码，它们提供音频数据的更紧缩版本；这些编码通常用于电话或语音录音。非线性编码将原始声音的幅度通过非线性函数映射到存储值，该函数可以设计为给予安静声音比响亮声音更多的幅度分辨率。
- en: A frame contains the data for all channels at a particular time. For PCM-encoded
    data, the frame is simply the set of simultaneous samples in all channels, for
    a given instant in time, without any additional information. In this case, the
    frame rate is equal to the sample rate, and the frame size in bytes is the number
    of channels multiplied by the sample size in bits, divided by the number of bits
    in a byte.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个帧包含特定时间所有通道的数据。对于PCM编码的数据，帧只是所有通道在给定时间点的同时样本集，没有任何附加信息。在这种情况下，帧速率等于采样率，帧大小以字节为单位是通道数乘以位采样大小，再除以字节的位数。
- en: For other kinds of encodings, a frame might contain additional information besides
    the samples, and the frame rate might be completely different from the sample
    rate. For example, consider the MP3 (MPEG-1 Audio Layer 3) encoding, which is
    not explicitly mentioned in the current version of the Java Sound API, but which
    could be supported by an implementation of the Java Sound API or by a third-party
    service provider. In MP3, each frame contains a bundle of compressed data for
    a series of samples, not just one sample per channel. Because each frame encapsulates
    a whole series of samples, the frame rate is slower than the sample rate. The
    frame also contains a header. Despite the header, the frame size in bytes is less
    than the size in bytes of the equivalent number of PCM frames. (After all, the
    purpose of MP3 is to be more compact than PCM data.) For such an encoding, the
    sample rate and sample size refer to the PCM data that the encoded sound will
    eventually be converted into before being delivered to a digital-to-analog converter
    (DAC).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型的编码，一个帧可能包含除样本之外的附加信息，并且帧速率可能与采样率完全不同。例如，考虑MP3（MPEG-1音频第三层）编码，它在当前版本的Java
    Sound API中没有明确提到，但可以由Java Sound API的实现或第三方服务提供商支持。在MP3中，每个帧包含一系列样本的压缩数据包，而不仅仅是每个通道的一个样本。由于每个帧封装了一整个系列的样本，因此帧速率比采样率慢。帧还包含一个头部。尽管有头部，但帧的字节大小比等量的PCM帧的字节大小要小。（毕竟，MP3的目的是比PCM数据更紧凑。）对于这种编码，采样率和采样大小指的是编码后的声音最终将被转换成的PCM数据，然后传递给数字模拟转换器（DAC）。
- en: File Formats
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件格式
- en: A file format specifies the structure of a sound file, including not only the
    format of the raw audio data in the file, but also other information that can
    be stored in the file. Sound files come in various standard varieties, such as
    WAVE (also known as WAV, and often associated with PCs), AIFF (often associated
    with Macintoshes), and AU (often associated with UNIX systems). The different
    types of sound file have different structures. For example, they might have a
    different arrangement of data in the file's "header." A header contains descriptive
    information that typically precedes the file's actual audio samples, although
    some file formats allow successive "chunks" of descriptive and audio data. The
    header includes a specification of the data format that was used for storing the
    audio in the sound file. Any of these types of sound file can contain various
    data formats (although usually there is only one data format within a given file),
    and the same data format can be used in files that have different file formats.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式指定了声音文件的结构，包括文件中原始音频数据的格式，以及可以存储在文件中的其他信息。声音文件有各种标准品种，如WAVE（也称为WAV，通常与PC关联）、AIFF（通常与Macintosh关联）和AU（通常与UNIX系统关联）。不同类型的声音文件具有不同的结构。例如，它们可能在文件的“头部”中具有不同的数据排列。头部包含描述性信息，通常在文件的实际音频样本之前，尽管一些文件格式允许连续的描述性和音频数据“块”。头部包括规范用于存储声音文件中音频的数据格式。任何这些类型的声音文件都可以包含各种数据格式（尽管通常在给定文件中只有一个数据格式），并且相同的数据格式可以在具有不同文件格式的文件中使用。
- en: 'In the Java Sound API, a file format is represented by an [`AudioFileFormat`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioFileFormat.html)
    object, which contains:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Sound API中，文件格式由一个[`AudioFileFormat`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioFileFormat.html)对象表示，其中包含：
- en: The file type (WAVE, AIFF, etc.)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件类型（WAVE、AIFF等）
- en: The file's length in bytes
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的字节长度
- en: The length, in frames, of the audio data contained in the file
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件中包含的音频数据的帧数长度
- en: An AudioFormat object that specifies the data format of the audio data contained
    in the file
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指定文件中包含的音频数据的数据格式的AudioFormat对象
- en: The [`AudioSystem`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioSystem.html)
    class provides methods for reading and writing sounds in different file formats,
    and for converting between different data formats. Some of the methods let you
    access a file's contents through a kind of stream called an [`AudioInputStream`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioInputStream.html)
    . An `AudioInputStream` is a subclass of the [`InputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html)
    class, which encapsulates a series of bytes that can be read sequentially. To
    its superclass, the `AudioInputStream` class adds knowledge of the bytes' audio
    data format (represented by an `AudioFormat` object). By reading a sound file
    as an `AudioInputStream`, you get immediate access to the samples, without having
    to worry about the sound file's structure (its header, chunks, etc.). A single
    method invocation gives you all the information you need about the data format
    and the file type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AudioSystem`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioSystem.html)类提供了用于读取和写入不同文件格式的声音以及在不同数据格式之间转换的方法。其中一些方法允许您通过一种称为[`AudioInputStream`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioInputStream.html)的流来访问文件的内容。`AudioInputStream`是[`InputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html)类的子类，封装了可以按顺序读取的一系列字节。`AudioInputStream`类添加了有关字节音频数据格式的知识（由`AudioFormat`对象表示）到其超类。通过将声音文件作为`AudioInputStream`读取，您可以立即访问样本，而无需担心声音文件的结构（其头部、块等）。单个方法调用将为您提供有关数据格式和文件类型的所有信息。'
- en: What is a Mixer?
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是混音器？
- en: Many application programming interfaces (APIs) for sound make use of the notion
    of an audio *device*. A device is often a software interface to a physical input/output
    device. For example, a sound-input device might represent the input capabilities
    of a sound card, including a microphone input, a line-level analog input, and
    perhaps a digital audio input.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多声音应用程序编程接口（API）使用音频*设备*的概念。设备通常是对物理输入/输出设备的软件接口。例如，声音输入设备可能代表声卡的输入功能，包括麦克风输入、线路级模拟输入，以及可能的数字音频输入。
- en: In the Java Sound API, devices are represented by [`Mixer`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Mixer.html)
    objects. The purpose of a mixer is to handle one or more streams of audio input
    and one or more streams of audio output. In the typical case, it actually mixes
    together multiple incoming streams into one outgoing stream. A `Mixer` object
    can represent the sound-mixing capabilities of a physical device such as a sound
    card, which might need to mix the sound coming in to the computer from various
    inputs, or the sound coming from application programs and going to outputs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Sound API中，设备由[`Mixer`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Mixer.html)对象表示。混音器的目的是处理一个或多个音频输入流和一个或多个音频输出流。在典型情况下，它实际上将多个传入流混合成一个传出流。一个`Mixer`对象可以表示物理设备（如声卡）的声音混合功能，该设备可能需要混合从各种输入到计算机的声音，或者从应用程序到输出的声音。
- en: Alternatively, a `Mixer` object can represent sound-mixing capabilities that
    are implemented entirely in software, without any inherent interface to physical
    devices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个`Mixer`对象可以表示完全在软件中实现的声音混合功能，而没有与物理设备的固有接口。
- en: In the Java Sound API, a component such as the microphone input on a sound card
    is not itself considered a device — that is, a mixer — but rather a *port* into
    or out of the mixer. A port typically provides a single stream of audio into or
    out of the mixer (although the stream can be multichannel, such as stereo). The
    mixer might have several such ports. For example, a mixer representing a sound
    card's output capabilities might mix several streams of audio together, and then
    send the mixed signal to any or all of various output ports connected to the mixer.
    These output ports could be (for example) a headphone jack, a built-in speaker,
    or a line-level output.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Sound API中，诸如声卡上的麦克风输入之类的组件本身并不被视为设备——也就是混音器——而是混音器内或外的*端口*。一个端口通常提供一个音频流进入或离开混音器（尽管该流可以是多声道的，比如立体声）。混音器可能有几个这样的端口。例如，代表声卡输出功能的混音器可能将几个音频流混合在一起，然后将混合信号发送到连接到混音器的任何或所有各种输出端口。这些输出端口可以是（例如）耳机插孔、内置扬声器或线路级输出。
- en: To understand the notion of a mixer in the Java Sound API, it helps to visualize
    a physical mixing console, such as those used in live concerts and recording studios.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Java Sound API中混音器的概念，有助于想象一个物理混音控制台，比如在现场音乐会和录音室中使用的那种。
- en: '![The following context describes this figure.](../Images/cc66c021ba6fd4b7845c08dd34f66ccb.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![以下上下文描述这幅图。](../Images/cc66c021ba6fd4b7845c08dd34f66ccb.png)'
- en: A Physical Mixing Console
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 物理混音控制台
- en: A physical mixer has "strips" (also called "slices"), each representing a path
    through which a single audio signal goes into the mixer for processing. The strip
    has knobs and other controls by which you can control the volume and pan (placement
    in the stereo image) for the signal in that strip. Also, the mixer might have
    a separate bus for effects such as reverb, and this bus can be connected to an
    internal or external reverberation unit. Each strip has a potentiometer that controls
    how much of that strip's signal goes into the reverberated mix. The reverberated
    ("wet") mix is then mixed with the "dry" signals from the strips. A physical mixer
    sends this final mixture to an output bus, which typically goes to a tape recorder
    (or disk-based recording system) and/or speakers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 物理混音器有“条带”（也称为“切片”），每个条带代表一个音频信号通过混音器进行处理的路径。该条带有旋钮和其他控件，通过这些控件可以控制该条带中信号的音量和声像（在立体声图像中的位置）。此外，混音器可能有一个用于混响等效果的单独总线，该总线可以连接到内部或外部混响单元。每个条带都有一个电位器，用于控制该条带信号的多少进入混响混合中。混响（“湿”）混合然后与来自条带的“干”信号混合。物理混音器将这个最终混合发送到一个输出总线，通常连接到磁带录音机（或基于磁盘的录音系统）和/或扬声器。
- en: Imagine a live concert that is being recorded in stereo. Cables (or wireless
    connections) coming from the many microphones and electric instruments on stage
    are plugged into the inputs of the mixing console. Each input goes to a separate
    strip of the mixer, as illustrated. The sound engineer decides on the settings
    of the gain, pan, and reverb controls. The output of all the strips and the reverb
    unit are mixed together into two channels. These two channels go to two outputs
    on the mixer, into which cables are plugged that connect to the stereo tape recorder's
    inputs. The two channels are perhaps also sent via an amplifier to speakers in
    the hall, depending on the type of music and the size of the hall.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一场正在立体录制的现场音乐会。来自舞台上许多麦克风和电子乐器的电缆（或无线连接）插入混音台的输入。每个输入都进入混音器的一个单独条道，如图所示。音响工程师决定增益、声像和混响控件的设置。所有条道和混响单元的输出混合成两个声道。这两个声道进入混音器的两个输出，插入连接到立体磁带录音机输入的电缆中。这两个声道可能也通过放大器发送到大厅的扬声器，这取决于音乐类型和大厅的大小。
- en: Now imagine a recording studio, in which each instrument or singer is recorded
    to a separate track of a multitrack tape recorder. After the instruments and singers
    have all been recorded, the recording engineer performs a "mixdown" to combine
    all the taped tracks into a two-channel (stereo) recording that can be distributed
    on compact discs. In this case, the input to each of the mixer's strips is not
    a microphone, but one track of the multitrack recording. Once again, the engineer
    can use controls on the strips to decide each track's volume, pan, and reverb
    amount. The mixer's outputs go once again to a stereo recorder and to stereo speakers,
    as in the example of the live concert.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一个录音室，在录音室中，每个乐器或歌手都被录制到多轨磁带录音机的单独轨道上。在所有乐器和歌手都被录制后，录音工程师执行“混音”操作，将所有录制的轨道组合成可以分发到CD上的两声道（立体声）录音。在这种情况下，混音器条的每个输入不是麦克风，而是多轨录音的一个轨道。工程师可以再次使用条上的控件来决定每个轨道的音量、声像和混响量。混音器的输出再次进入立体录音机和立体扬声器，就像现场音乐会的例子一样。
- en: 'These two examples illustrate two different uses of a mixer: to capture multiple
    input channels, combine them into fewer tracks, and save the mixture, or to play
    back multiple tracks while mixing them down to fewer tracks.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子说明了混音器的两种不同用途：捕获多个输入通道，将它们组合成较少的轨道并保存混合物，或者播放多个轨道同时将它们混合成较少的轨道。
- en: In the Java Sound API, a mixer can similarly be used for input (capturing audio)
    or output (playing back audio). In the case of input, the *source* from which
    the mixer gets audio for mixing is one or more input ports. The mixer sends the
    captured and mixed audio streams to its *target*, which is an object with a buffer
    from which an application program can retrieve this mixed audio data. In the case
    of audio output, the situation is reversed. The mixer's source for audio is one
    or more objects containing buffers into which one or more application programs
    write their sound data; and the mixer's target is one or more output ports.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Sound API中，混音器可以类似地用于输入（捕获音频）或输出（播放音频）。在输入的情况下，混音器获取音频进行混音的*源*是一个或多个输入端口。混音器将捕获和混合的音频流发送到其*目标*，这是一个带有缓冲区的对象，应用程序可以从中检索这些混合音频数据。在音频输出的情况下，情况则相反。混音器的音频源是一个或多个包含缓冲区的对象，其中一个或多个应用程序将其声音数据写入其中；混音器的目标是一个或多个输出端口。
- en: What is a Line?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是一条线？
- en: The metaphor of a physical mixing console is also useful for understanding the
    Java Sound API's concept of a *line*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个物理混音台的隐喻也有助于理解Java Sound API对*线路*概念的理解。
- en: A line is an element of the digital audio "pipeline" that is, a path for moving
    audio into or out of the system. Usually the line is a path into or out of a mixer
    (although technically the mixer itself is also a kind of line).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一条线是数字音频“管道”的一个元素，即将音频移入或移出系统的路径。通常，该线路是进入或离开混音器的路径（尽管从技术上讲，混音器本身也是一种线路）。
- en: Audio input and output ports are lines. These are analogous to the microphones
    and speakers connected to a physical mixing console. Another kind of line is a
    data path through which an application program can get input audio from, or send
    output audio to, a mixer. These data paths are analogous to the tracks of the
    multitrack recorder connected to the physical mixing console.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 音频输入和输出端口是线路。这些类似于连接到物理混音台的麦克风和扬声器。另一种线路是应用程序可以通过其中获取输入音频或将输出音频发送到混音器的数据路径。这些数据路径类似于连接到物理混音台的多轨录音机的轨道。
- en: One difference between lines in the Java Sound API and those of a physical mixer
    is that the audio data flowing through a line in the Java Sound API can be mono
    or multichannel (for example, stereo). By contrast, each of a physical mixer's
    inputs and outputs is typically a single channel of sound. To get two or more
    channels of output from the physical mixer, two or more physical outputs are normally
    used (at least in the case of analog sound; a digital output jack is often multichannel).
    In the Java Sound API, the number of channels in a line is specified by the [`AudioFormat`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioFormat.html)
    of the data that is currently flowing through the line.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Java Sound API中的线路与物理混音器的一个区别是，通过Java Sound API中的线路流动的音频数据可以是单声道或多声道（例如，立体声）。相比之下，物理混音器的每个输入和输出通常是单声道的声音。要从物理混音器获得两个或更多声道的输出，通常会使用两个或更多个物理输出（至少在模拟声音的情况下；数字输出插孔通常是多声道的）。在Java
    Sound API中，线路中的声道数由当前流经线路的数据的[`AudioFormat`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/AudioFormat.html)指定。
- en: 'Let''s now examine some specific kinds of lines and mixers. The following diagram
    shows different types of lines in a simple audio-output system that could be part
    of an implementation of the Java Sound API:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一些特定类型的线路和混音器。以下图表显示了Java Sound API实现的简单音频输出系统中不同类型的线路：
- en: '![The following context describes this figure.](../Images/1ce65a06de41ed2e8567883ef93424aa.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![以下内容描述此图。](../Images/1ce65a06de41ed2e8567883ef93424aa.png)'
- en: A Possible Configuration of Lines for Audio Output
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 音频输出的可能配置线路
- en: 'In this example, an application program has gotten access to some available
    inputs of an audio-input mixer: one or more *clips* and *source data lines*. A
    clip is a mixer input (a kind of line) into which you can load audio data prior
    to playback; a source data line is a mixer input that accepts a real-time stream
    of audio data. The application program preloads audio data from a sound file into
    the clips. It then pushes other audio data into the source data lines, a buffer
    at a time. The mixer reads data from all these lines, each of which may have its
    own reverberation, gain, and pan controls, and mixes the dry audio signals with
    the wet (reverberated) mix. The mixer delivers its final output to one or more
    output ports, such as a speaker, a headphone jack, and a line-out jack.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个应用程序已经获得了音频输入混音器的一些可用输入：一个或多个*片段*和*源数据线路*。片段是一个混音器输入（一种线路），你可以在播放之前将音频数据加载到其中；源数据线路是一个接受实时音频数据流的混音器输入。应用程序将音频数据从声音文件预加载到片段中。然后，它将其他音频数据一次一个缓冲区地推送到源数据线路中。混音器从所有这些线路中读取数据，每个线路可能有自己的混响、增益和声像控制，并将干净的音频信号与湿润（混响）混合。混音器将最终输出传送到一个或多个输出端口，例如扬声器、耳机插孔和线路输出插孔。
- en: Although the various lines are depicted as separate rectangles in the diagram,
    they are all "owned" by the mixer, and can be considered integral parts of the
    mixer. The reverb, gain, and pan rectangles represent processing controls (rather
    than lines) that can be applied by the mixer to data flowing through the lines.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在图中各个线路被描绘为单独的矩形，但它们都是混音器的“所有权”，可以被视为混音器的组成部分。混响、增益和声像矩形代表混音器可以应用于流经线路的数据的处理控制（而不是线路）。
- en: Note that this is just one example of a possible mixer that is supported by
    the API. Not all audio configurations will have all the features illustrated.
    An individual source data line might not support panning, a mixer might not implement
    reverb, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是API支持的可能混音器的一个示例。并非所有音频配置都具有所示的所有功能。个别源数据线路可能不支持声像控制，混音器可能不实现混响等。
- en: 'A simple audio-input system might be similar:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的音频输入系统可能类似：
- en: '![The following context describes this figure](../Images/4cb4e85642a1adb1b468606ba7f97b4b.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![以下内容描述此图](../Images/4cb4e85642a1adb1b468606ba7f97b4b.png)'
- en: A Possible Configuration of Lines for Audio Input
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 音频输入线路的可能配置
- en: Here, data flows into the mixer from one or more input ports, commonly the microphone
    or the line-in jack. Gain and pan are applied, and the mixer delivers the captured
    data to an application program via the mixer's target data line. A target data
    line is a mixer output, containing the mixture of the streamed input sounds. The
    simplest mixer has just one target data line, but some mixers can deliver captured
    data to multiple target data lines simultaneously.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数据从一个或多个输入端口流入混音器，通常是麦克风或线路输入插孔。增益和声像被应用，混音器通过混音器的目标数据线将捕获的数据传递给应用程序。目标数据线是混音器的输出，包含流式输入声音的混合物。最简单的混音器只有一个目标数据线，但有些混音器可以同时将捕获的数据传递给多个目标数据线。
- en: The Line Interface Hierarchy
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线接口层次结构
- en: Now that we've seen some functional pictures of what lines and mixers are, let's
    discuss them from a slightly more programmatic perspective. Several types of line
    are defined by subinterfaces of the basic [`Line`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Line.html)
    interface. The interface hierarchy is shown below.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些关于线路和混音器的功能图片，让我们从稍微更具编程视角的角度来讨论它们。通过基本[`Line`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Line.html)接口的子接口定义了几种类型的线路。接口层次结构如下所示。
- en: '![The following context describes this figure](../Images/067b588c12115e5aed0badd19b17f30c.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![以下内容描述了这幅图](../Images/067b588c12115e5aed0badd19b17f30c.png)'
- en: The Line Interface Hierarchy
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 线接口层次结构
- en: 'The base interface, [`Line`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Line.html),
    describes the minimal functionality common to all lines:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 基本接口[`Line`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Line.html)描述了所有线路共有的最小功能：
- en: 'Controls – Data lines and ports often have a set of controls that affect the
    audio signal passing through the line. The Java Sound API specifies control classes
    that can be used to manipulate aspects of sound such as: gain (which affects the
    signal''s volume in decibels), pan (which affects the sound''s right-left positioning,
    reverb (which adds reverberation to the sound to emulate different kinds of room
    acoustics), and sample rate (which affects the rate of playback as well as the
    sound''s pitch).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件 - 数据线和端口通常具有一组控件，影响通过线路传递的音频信号。Java Sound API 指定了可以用于操纵声音方面的控件类，例如：增益（影响信号的分贝音量）、声像（影响声音的左右定位）、混响（为声音添加混响以模拟不同种类的房间声学）和采样率（影响播放速率以及声音的音调）。
- en: Open or closed status – Successful opening of a line guarantees that resources
    have been allocated to the line. A mixer has a finite number of lines, so at some
    point multiple application programs (or the same one) might vie for usage of the
    mixer's lines. Closing a line indicates that any resources used by the line may
    now be released.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开或关闭状态 - 成功打开线路保证已为线路分配了资源。混音器具有有限数量的线路，因此在某些时候，多个应用程序（或同一个应用程序）可能会竞争使用混音器的线路。关闭线路表示线路使用的任何资源现在可以被释放。
- en: Events – A line generates events when it opens or closes. Subinterfaces of `Line`
    can introduce other types of events. When a line generates an event, the event
    is sent to all objects that have registered to "listen" for events on that line.
    An application program can create these objects, register them to listen for line
    events, and react to the events as desired.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件 - 当线路打开或关闭时，线路会生成事件。`Line`的子接口可以引入其他类型的事件。当线路生成事件时，事件会发送给所有已注册在该线路上“监听”事件的对象。应用程序可以创建这些对象，将它们注册为监听线路事件，并根据需要对事件做出反应。
- en: We'll now examine the subinterfaces of the `Line` interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将检查`Line`接口的子接口。
- en: '[`Ports`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Port.html)
    are simple lines for input or output of audio to or from audio devices. As mentioned
    earlier, some common types of ports are the microphone, line input, CD-ROM drive,
    speaker, headphone, and line output.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[`端口`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Port.html)是用于音频输入或输出到音频设备的简单线路。如前所述，一些常见类型的端口是麦克风、线路输入、CD-ROM
    驱动器、扬声器、耳机和线路输出。'
- en: The [`Mixer`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Mixer.html)
    interface represents a mixer, of course, which as we have seen represents either
    a hardware or a software device. The `Mixer` interface provides methods for obtaining
    a mixer's lines. These include source lines, which feed audio to the mixer, and
    target lines, to which the mixer delivers its mixed audio. For an audio-input
    mixer, the source lines are input ports such as the microphone input, and the
    target lines are [`TargetDataLines`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/TargetDataLine.html)
    (described below), which deliver audio to the application program. For an audio-output
    mixer, on the other hand, the source lines are [`Clips`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Clip.html)
    or [`SourceDataLines`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/SourceDataLine.html)
    (described below), to which the application program feeds audio data, and the
    target lines are output ports such as the speaker.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Mixer`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Mixer.html)接口代表一个混音器，当然，正如我们所见，它代表一个硬件或软件设备。`Mixer`接口提供了获取混音器线的方法。这些包括源线，将音频馈送到混音器，以及目标线，混音器将其混合音频传递给的线。对于音频输入混音器，源线是输入端口，如麦克风输入，目标线是[`TargetDataLines`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/TargetDataLine.html)（下文描述），它��将音频传递给应用程序。另一方面，对于音频输出混音器，源线是[`Clips`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/Clip.html)或[`SourceDataLines`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/SourceDataLine.html)（下文描述），应用程序向其馈送音频数据，目标线是输出端口，如扬声器。'
- en: A `Mixer` is defined as having one or more source lines and one or more target
    lines. Note that this definition means that a mixer need not actually mix data;
    it might have only a single source line. The `Mixer` API is intended to encompass
    a variety of devices, but the typical case supports mixing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Mixer`被定义为具有一个或多个源线和一个或多个目标线。请注意，这个定义意味着一个混音器不一定实际混合数据；它可能只有一个单一的源线。`Mixer`
    API旨在涵盖各种设备，但典型情况下支持混音。
- en: The `Mixer` interface supports synchronization; that is, you can specify that
    two or more of a mixer's lines be treated as a synchronized group. Then you can
    start, stop, or close all those data lines by sending a single message to any
    line in the group, instead of having to control each line individually. With a
    mixer that supports this feature, you can obtain sample-accurate synchronization
    between lines.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mixer`接口支持同步；也就是说，您可以指定一个混音器的两个或多个线被视为同步组。然后，您可以通过向组中的任何线发送单个消息来启动、停止或关闭所有这些数据线，而不必单独控制每条线。使用支持此功能的混音器，您可以在线之间获得样本精确的同步。'
- en: 'The generic `Line` interface does not provide a means to start and stop playback
    or recording. For that you need a data line. The [`DataLine`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/DataLine.html)
    interface supplies the following additional media-related features beyond those
    of a `Line`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的`Line`接口不提供启动和停止播放或录制的方法。为此，您需要一个数据线。[`DataLine`](https://docs.oracle.com/javase/8/docs/api/javax/sound/sampled/DataLine.html)接口提供了以下额外的与媒体相关的功能，超出了`Line`的功能：
- en: Audio format – Each data line has an audio format associated with its data stream.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频格式 – 每个数据线都有与其数据流相关联的音频格式。
- en: Media position – A data line can report its current position in the media, expressed
    in sample frames. This represents the number of sample frames captured by or rendered
    from the data line since it was opened.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体位置 – 数据线可以报告其在媒体中的当前位置，以采样帧表示。这代表自数据线打开以来捕获或渲染的采样帧数量。
- en: Buffer size – This is the size of the data line's internal buffer in bytes.
    For a source data line, the internal buffer is one to which data can be written,
    and for a target data line it's one from which data can be read.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区大小 – 这是数据线内部缓冲区的大小，以字节为单位。对于源数据线，内部缓冲区是可以写入数据的，对于目标数据线，它是可以读取数据的。
- en: Level (the current amplitude of the audio signal)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音量（音频信号的当前振幅）
- en: Start and stop playback or capture
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和停止播放或捕获
- en: Pause and resume playback or capture
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停和恢复播放或捕获
- en: Flush (discard unprocessed data from the queue)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新（丢弃队列中的未处理数据）
- en: Drain (block until all unprocessed data has been drained from the queue, and
    the data line's buffer has become empty)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排空（阻塞直到队列中的所有未处理数据都被排空，并且数据线的缓冲区变为空）
- en: Active status – A data line is considered active if it is engaged in active
    presentation or capture of audio data to or from a mixer.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动状态 – 如果数据线参与从混音器捕获音频数据或向混音器捕获音频数据，则被视为活动状态。
- en: Events – `START` and `STOP` events are produced when active presentation or
    capture of data from or to the data line starts or stops.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件 – `START` 和 `STOP` 事件在从数据线开始或停止活动演示或捕获数据时产生。
- en: A `TargetDataLine` receives audio data from a mixer. Commonly, the mixer has
    captured audio data from a port such as a microphone; it might process or mix
    this captured audio before placing the data in the target data line's buffer.
    The `TargetDataLine` interface provides methods for reading the data from the
    target data line's buffer and for determining how much data is currently available
    for reading.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`TargetDataLine` 从混音器接收音频数据。通常，混音器从诸如麦克风之类的端口捕获音频数据；在将数据放入目标数据线缓冲区之前，它可能会处理或混合此捕获的音频。`TargetDataLine`
    接口提供了从目标数据线缓冲区读取数据的方法，并确定当前可用于读取的数据量。'
- en: A `SourceDataLine` receives audio data for playback. It provides methods for
    writing data to the source data line's buffer for playback, and for determining
    how much data the line is prepared to receive without blocking.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SourceDataLine` 接收用于播放的音频数据。它提供了将数据写入源数据线缓冲区以进行播放的方法，并确定数据线准备接收多少数据而不会阻塞。'
- en: A `Clip` is a data line into which audio data can be loaded prior to playback.
    Because the data is pre-loaded rather than streamed, the clip's duration is known
    before playback, and you can choose any starting position in the media. Clips
    can be looped, meaning that upon playback, all the data between two specified
    loop points will repeat a specified number of times, or indefinitely.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clip` 是一个数据线，可以在播放之前加载音频数据。由于数据是预加载而不是流式传输，因此在播放之前可以知道剪辑的持续时间，并且可以选择媒体中的任何起始位置。剪辑可以循环播放，意味着在播放时，两个指定循环点之间的所有数据将重复指定次数，或者无限循环。'
- en: This section has introduced most of the important interfaces and classes of
    the sampled-audio API. Subsequent sections show how you can access and use these
    objects in your application program.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了采样音频 API 中大部分重要的接口和类。后续章节将展示如何在应用程序中访问和使用这些对象。
