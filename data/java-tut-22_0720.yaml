- en: Retrieving and Modifying Values from Result Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从结果集中检索和修改值
- en: 原文：[https://docs.oracle.com/javase/tutorial/jdbc/basics/retrieving.html](https://docs.oracle.com/javase/tutorial/jdbc/basics/retrieving.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.oracle.com/javase/tutorial/jdbc/basics/retrieving.html](https://docs.oracle.com/javase/tutorial/jdbc/basics/retrieving.html)
- en: 'The following method, [`CoffeesTable.viewTable`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java),
    outputs the contents of the `COFFEES` tables, and demonstrates the use of `ResultSet`
    objects and cursors:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的方法，[`CoffeesTable.viewTable`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java)，输出了
    `COFFEES` 表的内容，并演示了 `ResultSet` 对象和游标的使用：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A `ResultSet` object is a table of data representing a database result set,
    which is usually generated by executing a statement that queries the database.
    For example, the `CoffeeTables.viewTable` method creates a `ResultSet`, `rs`,
    when it executes the query through the `Statement` object, `stmt`. Note that a
    `ResultSet` object can be created through any object that implements the `Statement`
    interface, including `PreparedStatement`, `CallableStatement`, and `RowSet`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` 对象是表示数据库结果集的数据表，通常是通过执行查询数据库的语句生成的。例如，当 `CoffeeTables.viewTable`
    方法通过 `Statement` 对象 `stmt` 执行查询时，会创建一个 `ResultSet` 对象 `rs`。请注意，可以通过实现 `Statement`
    接口的任何对象创建 `ResultSet` 对象，包括 `PreparedStatement`、`CallableStatement` 和 `RowSet`。'
- en: You access the data in a `ResultSet` object through a cursor. Note that this
    cursor is not a database cursor. This cursor is a pointer that points to one row
    of data in the `ResultSet`. Initially, the cursor is positioned before the first
    row. The method `ResultSet.next` moves the cursor to the next row. This method
    returns `false` if the cursor is positioned after the last row. This method repeatedly
    calls the `ResultSet.next` method with a `while` loop to iterate through all the
    data in the `ResultSet`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过游标访问 `ResultSet` 对象中的数据。请注意，这个游标不是数据库游标。这个游标是指向 `ResultSet` 中一行数据的指针。最初，游标位于第一行之前。方法
    `ResultSet.next` 将游标移动到下一行。如果游标位于最后一行之后，则此方法返回 `false`。此方法使用 `while` 循环重复调用 `ResultSet.next`
    方法来迭代 `ResultSet` 中的所有数据。
- en: 'This page covers the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本页涵盖以下主题：
- en: '[ResultSet Interface](#rs_interface)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ResultSet 接口](#rs_interface)'
- en: '[Retrieving Column Values from Rows](#retrieve_rs)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从行中检索列值](#retrieve_rs)'
- en: '[Cursors](#cursors)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[游标](#cursors)'
- en: '[Updating Rows in ResultSet Objects](#rs_update)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 ResultSet 对象中更新行](#rs_update)'
- en: '[Using Statement Objects for Batch Updates](#batch_updates)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 Statement 对象进行批量更新](#batch_updates)'
- en: '[Inserting Rows in ResultSet Objects](#rs_insert)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 ResultSet 对象中插入行](#rs_insert)'
- en: ResultSet Interface
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ResultSet 接口
- en: The `ResultSet` interface provides methods for retrieving and manipulating the
    results of executed queries, and `ResultSet` objects can have different functionality
    and characteristics. These characteristics are type, concurrency, and cursor *holdability*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` 接口提供了检索和操作执行查询结果的方法，`ResultSet` 对象可以具有不同的功能和特性。这些特性包括类型、并发性和游标*保持性*。'
- en: ResultSet Types
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ResultSet 类型
- en: 'The type of a `ResultSet` object determines the level of its functionality
    in two areas: the ways in which the cursor can be manipulated, and how concurrent
    changes made to the underlying data source are reflected by the `ResultSet` object.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` 对象的类型确定了其功能级别在两个方面：游标如何被操作，以及对底层数据源进行的并发更改如何反映在 `ResultSet` 对象中。'
- en: 'The sensitivity of a `ResultSet` object is determined by one of three different
    `ResultSet` types:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` 对象的灵敏度由三种不同的 `ResultSet` 类型之一确定：'
- en: '`TYPE_FORWARD_ONLY`: The result set cannot be scrolled; its cursor moves forward
    only, from before the first row to after the last row. The rows contained in the
    result set depend on how the underlying database generates the results. That is,
    it contains the rows that satisfy the query at either the time the query is executed
    or as the rows are retrieved.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE_FORWARD_ONLY`：结果集无法滚动；其游标仅向前移动，从第一行之前到最后一行之后。结果集中包含的行取决于底层数据库如何生成结果。也就是说，它包含在查询执行时满足查询的行，或者在检索行时满足查询的行。'
- en: '`TYPE_SCROLL_INSENSITIVE`: The result can be scrolled; its cursor can move
    both forward and backward relative to the current position, and it can move to
    an absolute position. The result set is insensitive to changes made to the underlying
    data source while it is open. It contains the rows that satisfy the query at either
    the time the query is executed or as the rows are retrieved.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE_SCROLL_INSENSITIVE`：结果可以滚动；其游标可以相对于当前位置向前和向后移动，并且可以移动到绝对位置。结果集对在打开时对基础数据源进行的更改是不敏感的。它包含在查询执行时满足查询的行，或者在检索行时满足查询的行。'
- en: '`TYPE_SCROLL_SENSITIVE`: The result can be scrolled; its cursor can move both
    forward and backward relative to the current position, and it can move to an absolute
    position. The result set reflects changes made to the underlying data source while
    the result set remains open.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE_SCROLL_SENSITIVE`：结果可以滚动；其游标可以相对于当前位置向前和向后移动，并且可以移动到绝对位置。结果集反映了在结果集保持打开状态时对基础数据源所做的更改。'
- en: The default `ResultSet` type is `TYPE_FORWARD_ONLY`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`ResultSet`类型是`TYPE_FORWARD_ONLY`。
- en: '**Note**: Not all databases and JDBC drivers support all `ResultSet` types.
    The method `DatabaseMetaData.supportsResultSetType` returns `true` if the specified
    `ResultSet` type is supported and `false` otherwise.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：并非所有数据库和JDBC驱动程序都支持所有`ResultSet`类型。如果指定的`ResultSet`类型受支持，则方法`DatabaseMetaData.supportsResultSetType`返回`true`，否则返回`false`。'
- en: ResultSet Concurrency
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ResultSet并发性
- en: The concurrency of a `ResultSet` object determines what level of update functionality
    is supported.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet`对象的并发性确定支持的更新功能级别。'
- en: 'There are two concurrency levels:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个并发级别：
- en: '`CONCUR_READ_ONLY`: The `ResultSet` object cannot be updated using the `ResultSet`
    interface.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONCUR_READ_ONLY`：`ResultSet`对象不能使用`ResultSet`接口进行更新。'
- en: '`CONCUR_UPDATABLE`: The `ResultSet` object can be updated using the `ResultSet`
    interface.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONCUR_UPDATABLE`：`ResultSet`对象可以使用`ResultSet`接口进行更新。'
- en: The default `ResultSet` concurrency is `CONCUR_READ_ONLY`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`ResultSet`并发性是`CONCUR_READ_ONLY`。
- en: '**Note**: Not all JDBC drivers and databases support concurrency. The method
    `DatabaseMetaData.supportsResultSetConcurrency` returns `true` if the specified
    concurrency level is supported by the driver and `false` otherwise.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：并非所有的JDBC驱动程序和数据库都支持并发性。如果指定的并发级别由驱动程序支持，则方法`DatabaseMetaData.supportsResultSetConcurrency`返回`true`，否则返回`false`。'
- en: The method [`CoffeesTable.modifyPrices`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java)
    demonstrates how to use a `ResultSet` object whose concurrency level is `CONCUR_UPDATABLE`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[`CoffeesTable.modifyPrices`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java)演示了如何使用并发级别为`CONCUR_UPDATABLE`的`ResultSet`对象。
- en: Cursor Holdability
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游标可保持性
- en: Calling the method `Connection.commit` can close the `ResultSet` objects that
    have been created during the current transaction. In some cases, however, this
    may not be the desired behavior. The `ResultSet` property *holdability* gives
    the application control over whether `ResultSet` objects (cursors) are closed
    when commit is called.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法`Connection.commit`可以关闭在当前事务期间创建的`ResultSet`对象。然而，在某些情况下，这可能不是期望的行为。`ResultSet`属性*holdability*使应用程序可以控制在调用`commit`时是否关闭`ResultSet`对象（游标）。
- en: 'The following `ResultSet` constants may be supplied to the `Connection` methods
    `createStatement`, `prepareStatement`, and `prepareCall`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`ResultSet`常量可以提供给`Connection`方法`createStatement`，`prepareStatement`和`prepareCall`：
- en: '`HOLD_CURSORS_OVER_COMMIT`: `ResultSet` cursors are not closed; they are *holdable*:
    they are held open when the method `commit` is called. Holdable cursors might
    be ideal if your application uses mostly read-only `ResultSet` objects.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HOLD_CURSORS_OVER_COMMIT`：`ResultSet`游标不会关闭；它们是*可保持的*：当调用`commit`方法时，它们保持打开状态。如果您的应用程序主要使用只读`ResultSet`对象，则可保持的游标可能是理想的。'
- en: '`CLOSE_CURSORS_AT_COMMIT`: `ResultSet` objects (cursors) are closed when the
    `commit` method is called. Closing cursors when this method is called can result
    in better performance for some applications.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOSE_CURSORS_AT_COMMIT`：在调用`commit`方法时关闭`ResultSet`对象（游标）。在调用此方法时关闭游标可能会提高某些应用程序的性能。'
- en: The default cursor holdability varies depending on your DBMS.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的游标可保持性取决于您的DBMS。
- en: '**Note**: Not all JDBC drivers and databases support holdable and non-holdable
    cursors. The following method, `JDBCTutorialUtilities.cursorHoldabilitySupport`,
    outputs the default cursor holdability of `ResultSet` objects and whether `HOLD_CURSORS_OVER_COMMIT`
    and `CLOSE_CURSORS_AT_COMMIT` are supported:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：并非所有的JDBC驱动程序和数据库都支持可保持和不可保持的游标。以下方法`JDBCTutorialUtilities.cursorHoldabilitySupport`输出`ResultSet`对象的默认游标保持性以及是否支持`HOLD_CURSORS_OVER_COMMIT`和`CLOSE_CURSORS_AT_COMMIT`：'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Retrieving Column Values from Rows
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从行中检索列值
- en: The `ResultSet` interface declares getter methods (for example, `getBoolean`
    and `getLong`) for retrieving column values from the current row. You can retrieve
    values using either the index number of the column or the alias or name of the
    column. The column index is usually more efficient. Columns are numbered from
    1\. For maximum portability, result set columns within each row should be read
    in left-to-right order, and each column should be read only once.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet`接口声明了获取器方法（例如，`getBoolean`和`getLong`）用于从当前行检索列值。您可以使用列的索引号或别名或名称检索值。列索引通常更有效。列从1开始编号。为了最大的可移植性，应按照从左到右的顺序读取每行中的结果集列，并且每列只能读取一次。'
- en: 'For example, the following method, [`CoffeesTable.alternateViewTable`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java),
    retrieves column values by number:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下方法[`CoffeesTable.alternateViewTable`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java)，通过编号检索列值：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Strings used as input to getter methods are case-insensitive. When a getter
    method is called with a string and more than one column has the same alias or
    name as the string, the value of the first matching column is returned. The option
    to use a string as opposed to an integer is designed to be used when column aliases
    and names are used in the SQL query that generated the result set. For columns
    that are *not* explicitly named in the query (for example, `select * from COFFEES`)
    it is best to use column numbers. If column names are used, the developer should
    guarantee that they uniquely refer to the intended columns by using column aliases.
    A column alias effectively renames the column of a result set. To specify a column
    alias, use the SQL `AS` clause in the `SELECT` statement.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为获取器方法输入的字符串是不区分大小写的。当使用字符串调用获取器方法时，如果有多个列具有与字符串相同的别名或名称，则返回第一个匹配列的值。使用字符串而不是整数的选项设计用于在生成结果集的SQL查询中使用列别名和名称。对于在查询中*未*明确命名的列（例如，`select
    * from COFFEES`），最好使用列号。如果使用列名，开发人员应确保它们通过使用列别名唯一地引用所需的列。列别名有效地重命名了结果集的列。要指定列别名，请在`SELECT`语句中使用SQL
    `AS`子句。
- en: The getter method of the appropriate type retrieves the value in each column.
    For example, in the method `CoffeeTables.viewTable`, the first column in each
    row of the `ResultSet` `rs` is `COF_NAME`, which stores a value of SQL type `VARCHAR`.
    The method for retrieving a value of SQL type `VARCHAR` is `getString`. The second
    column in each row stores a value of SQL type `INTEGER`, and the method for retrieving
    values of that type is `getInt`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 适当类型的获取器方法检索每列中的值。例如，在方法`CoffeeTables.viewTable`中，`ResultSet` `rs`中每行的第一列是`COF_NAME`，存储了SQL类型`VARCHAR`的值。检索SQL类型`VARCHAR`值的方法是`getString`。每行中的第二列存储了SQL类型`INTEGER`的值，检索该类型值的方法是`getInt`。
- en: Note that although the method `getString` is recommended for retrieving the
    SQL types `CHAR` and `VARCHAR`, it is possible to retrieve any of the basic SQL
    types with it. Getting all values with `getString` can be very useful, but it
    also has its limitations. For instance, if it is used to retrieve a numeric type,
    `getString` converts the numeric value to a Java `String` object, and the value
    has to be converted back to a numeric type before it can be operated on as a number.
    In cases where the value is treated as a string anyway, there is no drawback.
    Furthermore, if you want an application to retrieve values of any standard SQL
    type other than SQL3 types, use the `getString` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然推荐使用方法`getString`来检索SQL类型`CHAR`和`VARCHAR`，但也可以使用它来检索任何基本的SQL类型。使用`getString`获取所有值可能非常有用，但也有其局限性。例如，如果用于检索数值类型，`getString`会将数值转换为Java
    `String`对象，必须将该值转换回数值类型才能作为数字进行操作。在将值视为字符串处理的情况下，没有任何缺点。此外，如果要求应用程序检索除SQL3类型以外的任何标准SQL类型的值，请使用`getString`方法。
- en: Cursors
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游标
- en: 'As mentioned previously, you access the data in a `ResultSet` object through
    a cursor, which points to one row in the `ResultSet` object. However, when a `ResultSet`
    object is first created, the cursor is positioned before the first row. The method
    `CoffeeTables.viewTable` moves the cursor by calling the `ResultSet.next` method.
    There are other methods available to move the cursor:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过光标访问`ResultSet`对象中的数据，光标指向`ResultSet`对象中的一行。但是，当创建`ResultSet`对象时，光标位于第一行之前。方法`CoffeeTables.viewTable`通过调用`ResultSet.next`方法移动光标。还有其他可用于移动光标的方法：
- en: '`next`: Moves the cursor forward one row. Returns `true` if the cursor is now
    positioned on a row and `false` if the cursor is positioned after the last row.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`: 将光标向前移动一行。如果光标现在位于一行上，则返回`true`，如果光标位于最后一行之后，则返回`false`。'
- en: '`previous`: Moves the cursor backward one row. Returns `true` if the cursor
    is now positioned on a row and `false` if the cursor is positioned before the
    first row.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previous`: 将光标向后移动一行。如果光标现在位于一行上，则返回`true`，如果光标位于第一行之前，则返回`false`。'
- en: '`first`: Moves the cursor to the first row in the `ResultSet` object. Returns
    `true` if the cursor is now positioned on the first row and `false` if the `ResultSet`
    object does not contain any rows.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`: 将光标移动到`ResultSet`对象中的第一行。如果光标现在位于第一行上，则返回`true`，如果`ResultSet`对象不包含任何行，则返回`false`。'
- en: '`last:`: Moves the cursor to the last row in the `ResultSet` object. Returns
    `true` if the cursor is now positioned on the last row and `false` if the `ResultSet`
    object does not contain any rows.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last:`: 将光标移动到`ResultSet`对象中的最后一行。如果光标现在位于最后一行上，则返回`true`，如果`ResultSet`对象不包含任何行，则返回`false`。'
- en: '`beforeFirst`: Positions the cursor at the start of the `ResultSet` object,
    before the first row. If the `ResultSet` object does not contain any rows, this
    method has no effect.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeFirst`: 将光标定位在`ResultSet`对象的开头，即第一行之前。如果`ResultSet`对象不包含任何行，则此方法不起作用。'
- en: '`afterLast`: Positions the cursor at the end of the `ResultSet` object, after
    the last row. If the `ResultSet` object does not contain any rows, this method
    has no effect.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterLast`: 将光标定位在`ResultSet`对象的末尾，即最后一行之后。如果`ResultSet`对象不包含任何行，则此方法不起作用。'
- en: '`relative(int rows)`: Moves the cursor relative to its current position.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`relative(int rows)`: 相对于当前位置移动光标。'
- en: '`absolute(int row)`: Positions the cursor on the row specified by the parameter
    `row`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`absolute(int row)`: 将光标定位在参数`row`指定的行上。'
- en: Note that the default sensitivity of a `ResultSet` is `TYPE_FORWARD_ONLY`, which
    means that it cannot be scrolled; you cannot call any of these methods that move
    the cursor, except `next`, if your `ResultSet` cannot be scrolled. The method
    `CoffeesTable.modifyPrices`, described in the following section, demonstrates
    how you can move the cursor of a `ResultSet`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ResultSet`的默认灵敏度是`TYPE_FORWARD_ONLY`，这意味着它不能滚动；如果您的`ResultSet`不能滚动，则除了`next`之外，您不能调用任何移动光标的方法。下一节中描述的`CoffeesTable.modifyPrices`方法演示了如何移动`ResultSet`的光标。
- en: Updating Rows in ResultSet Objects
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新`ResultSet`对象中的行
- en: You cannot update a default `ResultSet` object, and you can only move its cursor
    forward. However, you can create `ResultSet` objects that can be scrolled (the
    cursor can move backwards or move to an absolute position) and updated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能更新默认的`ResultSet`对象，只能将其光标向前移动。但是，您可以创建可以滚动（光标可以向后移动或移动到绝对位置）和更新的`ResultSet`对象。
- en: 'The following method, [`CoffeesTable.modifyPrices`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java),
    multiplies the `PRICE` column of each row by the argument `percentage`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法，[`CoffeesTable.modifyPrices`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java)，将每行的`PRICE`列乘以参数`percentage`：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The field `ResultSet.TYPE_SCROLL_SENSITIVE` creates a `ResultSet` object whose
    cursor can move both forward and backward relative to the current position and
    to an absolute position. The field `ResultSet.CONCUR_UPDATABLE` creates a `ResultSet`
    object that can be updated. See the `ResultSet` Javadoc for other fields you can
    specify to modify the behavior of `ResultSet` objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 字段`ResultSet.TYPE_SCROLL_SENSITIVE`创建一个`ResultSet`对象，其光标可以相对于当前位置和绝对位置向前和向后移动。字段`ResultSet.CONCUR_UPDATABLE`创建一个可更新的`ResultSet`对象。查看`ResultSet`
    Javadoc以了解可以指定的其他字段，以修改`ResultSet`对象的行为。
- en: The method `ResultSet.updateFloat` updates the specified column (in this example,
    `PRICE` with the specified `float` value in the row where the cursor is positioned.
    `ResultSet` contains various updater methods that enable you to update column
    values of various data types. However, none of these updater methods modifies
    the database; you must call the method `ResultSet.updateRow` to update the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`ResultSet.updateFloat`更新了指定列（在本例中为`PRICE`）中光标所在行的指定`float`值。`ResultSet`包含各种更新方法，使您能够更新各种数据类型的列值。然而，这些更新方法都不会修改数据库；您必须调用方法`ResultSet.updateRow`来更新数据库。
- en: Using Statement Objects for Batch Updates
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用语句对象进行批量更新
- en: '`Statement`, `PreparedStatement` and `CallableStatement` objects have a list
    of commands that is associated with them. This list may contain statements for
    updating, inserting, or deleting a row; and it may also contain DDL statements
    such as `CREATE TABLE` and `DROP TABLE`. It cannot, however, contain a statement
    that would produce a `ResultSet` object, such as a `SELECT` statement. In other
    words, the list can contain only statements that produce an update count.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Statement`、`PreparedStatement`和`CallableStatement`对象都有一个与之关联的命令列表。该列表可能包含用于更新、插入或删除行的语句；也可能包含DDL语句，如`CREATE
    TABLE`和`DROP TABLE`。但是，它不能包含会产生`ResultSet`对象的语句，比如`SELECT`语句。换句话说，该列表只能包含产生更新计数的语句。'
- en: The list, which is associated with a `Statement` object at its creation, is
    initially empty. You can add SQL commands to this list with the method `addBatch`
    and empty it with the method `clearBatch`. When you have finished adding statements
    to the list, call the method `executeBatch` to send them all to the database to
    be executed as a unit, or batch.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Statement`对象在创建时关联的列表最初为空。您可以使用方法`addBatch`向此列表添加SQL命令，并使用方法`clearBatch`清空它。当您完成向列表添加语句时，调用方法`executeBatch`将它们全部发送到数据库以作为一个单元或批量执行。
- en: 'For example, the following method, [`CoffeesTable.batchUpdate`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java),
    adds four rows to the `COFFEES` table with a batch update:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下方法，[`CoffeesTable.batchUpdate`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java)，使用批量更新向`COFFEES`表添加了四行：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following line disables auto-commit mode for the `Connection` object con
    so that the transaction will not be automatically committed or rolled back when
    the method `executeBatch` is called.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行禁用了`Connection`对象`con`的自动提交模式，这样当调用方法`executeBatch`时，事务将不会自动提交或回滚。
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To allow for correct error handling, you should always disable auto-commit mode
    before beginning a batch update.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确处理错误，您应该在开始批量更新之前始终禁用自动提交模式。
- en: The method `Statement.addBatch` adds a command to the list of commands associated
    with the `Statement` object `stmt`. In this example, these commands are all `INSERT
    INTO` statements, each one adding a row consisting of five column values. The
    values for the columns `COF_NAME` and `PRICE` are the name of the coffee and its
    price, respectively. The second value in each row is 49 because that is the identification
    number for the supplier, Superior Coffee. The last two values, the entries for
    the columns `SALES` and `TOTAL`, all start out being zero because there have been
    no sales yet. (`SALES` is the number of pounds of this row's coffee sold in the
    current week; `TOTAL` is the total of all the cumulative sales of this coffee.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`Statement.addBatch`将一个命令添加到与`Statement`对象`stmt`关联的命令列表中。在本例中，这些命令都是`INSERT
    INTO`语句，每个语句都添加了由五个列值组成的行。列`COF_NAME`和`PRICE`的值分别是咖啡的名称和价格。每行中的第二个值为49，因为这是供应商Superior
    Coffee的标识号。最后两个值，列`SALES`和`TOTAL`的条目，都从零开始，因为尚未进行销售。（`SALES`是本行咖啡在本周销售的磅数；`TOTAL`是该咖啡所有累计销售的总量。）
- en: 'The following line sends the four SQL commands that were added to its list
    of commands to the database to be executed as a batch:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将添加到其命令列表中的四个SQL命令发送到数据库以作为批量执行：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that `stmt` uses the method `executeBatch` to send the batch of insertions,
    not the method `executeUpdate`, which sends only one command and returns a single
    update count. The DBMS executes the commands in the order in which they were added
    to the list of commands, so it will first add the row of values for Amaretto,
    then add the row for Hazelnut, then Amaretto decaf, and finally Hazelnut decaf.
    If all four commands execute successfully, the DBMS will return an update count
    for each command in the order in which it was executed. The update counts that
    indicate how many rows were affected by each command are stored in the array `updateCounts`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`stmt`使用方法`executeBatch`发送插入的批处理，而不是使用方法`executeUpdate`，后者只发送一个命令并返回单个更新计数。数据库管理系统按照添加到命令列表的顺序执行命令，因此它将首先添加
    Amaretto 的值行，然后添加 Hazelnut 的行，然后是 Amaretto decaf，最后是 Hazelnut decaf。如果所有四个命令都成功执行，数据库管理系统将按照执行顺序为每个命令返回一个更新计数。指示每个命令影响了多少行的更新计数存储在数组`updateCounts`中。
- en: If all four of the commands in the batch are executed successfully, `updateCounts`
    will contain four values, all of which are 1 because an insertion affects one
    row. The list of commands associated with `stmt` will now be empty because the
    four commands added previously were sent to the database when `stmt` called the
    method `executeBatch`. You can at any time explicitly empty this list of commands
    with the method `clearBatch`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果批处理中的所有四个命令都成功执行，`updateCounts`将包含四个值，所有这些值都为 1，因为插入会影响一行。与`stmt`关联的命令列表现在将为空，因为之前添加的四个命令在`stmt`调用方法`executeBatch`时已发送到数据库。您随时可以使用方法`clearBatch`显式清空此命令列表。
- en: The `Connection.commit` method makes the batch of updates to the `COFFEES` table
    permanent. This method needs to be called explicitly because the auto-commit mode
    for this connection was disabled previously.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection.commit`方法使对`COFFEES`表的更新批量变为永久。之前为此连接禁用了自动提交模式，因此需要显式调用此方法。'
- en: The following line enables auto-commit mode for the current `Connection` object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行启用当前`Connection`对象的自动提交模式。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now each statement in the example will automatically be committed after it is
    executed, and it no longer needs to invoke the method `commit`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，示例中的每个语句在执行后将自动提交，并且不再需要调用方法`commit`。
- en: Performing Parameterized Batch Update
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行参数化的批量更新
- en: 'It is also possible to have a parameterized batch update, as shown in the following
    code fragment, where `con` is a `Connection` object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以进行参数化的批量更新，如下面的代码片段所示，其中`con`是一个`Connection`对象：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Handling Batch Update Exceptions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理批量更新异常
- en: You will get a `BatchUpdateException` when you call the method `executeBatch`
    if (1) one of the SQL statements you added to the batch produces a result set
    (usually a query) or (2) one of the SQL statements in the batch does not execute
    successfully for some other reason.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果批处理中的一个 SQL 语句产生结果集（通常是查询），或者批处理中的一个 SQL 语句由于其他原因未成功执行，当调用方法`executeBatch`时，将会收到`BatchUpdateException`。
- en: You should not add a query (a `SELECT` statement) to a batch of SQL commands
    because the method `executeBatch`, which returns an array of update counts, expects
    an update count from each SQL statement that executes successfully. This means
    that only commands that return an update count (commands such as `INSERT INTO`,
    `UPDATE`, `DELETE`) or that return 0 (such as `CREATE TABLE`, `DROP TABLE`, `ALTER
    TABLE`) can be successfully executed as a batch with the `executeBatch` method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该将查询（一个`SELECT`语句）添加到一批 SQL 命令中，因为方法`executeBatch`期望从每个成功执行的 SQL 语句中返回一个更新计数。这意味着只有返回更新计数的命令（如`INSERT
    INTO`，`UPDATE`，`DELETE`）或返回 0 的命令（如`CREATE TABLE`，`DROP TABLE`，`ALTER TABLE`）才能成功地作为一批与`executeBatch`方法一起执行。
- en: 'A `BatchUpdateException` contains an array of update counts that is similar
    to the array returned by the method `executeBatch`. In both cases, the update
    counts are in the same order as the commands that produced them. This tells you
    how many commands in the batch executed successfully and which ones they are.
    For example, if five commands executed successfully, the array will contain five
    numbers: the first one being the update count for the first command, the second
    one being the update count for the second command, and so on.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatchUpdateException`包含一个与`executeBatch`方法返回的数组类似的更新计数数组。在这两种情况下，更新计数与产生它们的命令的顺序相同。这告诉你批处理中有多少个命令成功执行以及它们是哪些。例如，如果五个命令成功执行，数组将包含五个数字：第一个是第一个命令的更新计数，第二个是第二个命令的更新计数，依此类推。'
- en: '`BatchUpdateException` is derived from `SQLException`. This means that you
    can use all of the methods available to an `SQLException` object with it. The
    following method, [`JDBCTutorialUtilities.printBatchUpdateException`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/JDBCTutorialUtilities.java),
    prints all of the `SQLException` information plus the update counts contained
    in a `BatchUpdateException` object. Because `BatchUpdateException.getUpdateCounts`
    returns an array of `int`, the code uses a `for` loop to print each of the update
    counts:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatchUpdateException`是从`SQLException`派生的。这意味着你可以使用所有`SQLException`对象可用的方法。以下方法，[`JDBCTutorialUtilities.printBatchUpdateException`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/JDBCTutorialUtilities.java)，打印了所有`SQLException`信息以及`BatchUpdateException`对象中包含的更新计数。因为`BatchUpdateException.getUpdateCounts`返回一个`int`数组，代码使用`for`循环打印每个更新计数：'
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inserting Rows in ResultSet Objects
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`ResultSet`对象中插入行
- en: '**Note**: Not all JDBC drivers support inserting new rows with the `ResultSet`
    interface. If you attempt to insert a new row and your JDBC driver database does
    not support this feature, a `SQLFeatureNotSupportedException` exception is thrown.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：并非所有的JDBC驱动程序都支持使用`ResultSet`接口插入新行。如果尝试插入新行而你的JDBC驱动程序数据库不支持此功能，将抛出`SQLFeatureNotSupportedException`异常。'
- en: 'The following method, [`CoffeesTable.insertRow`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java),
    inserts a row into the `COFFEES` through a `ResultSet` object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法，[`CoffeesTable.insertRow`](examples/JDBCTutorial/src/com/oracle/tutorial/jdbc/CoffeesTable.java)，通过`ResultSet`对象向`COFFEES`插入一行：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example calls the `Connection.createStatement` method with two arguments,
    `ResultSet.TYPE_SCROLL_SENSITIVE` and `ResultSet.CONCUR_UPDATABLE`. The first
    value enables the cursor of the `ResultSet` object to be moved both forward and
    backward. The second value, `ResultSet.CONCUR_UPDATABLE`, is required if you want
    to insert rows into a `ResultSet` object; it specifies that it can be updatable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例调用`Connection.createStatement`方法，带有两个参数，`ResultSet.TYPE_SCROLL_SENSITIVE`和`ResultSet.CONCUR_UPDATABLE`。第一个值使`ResultSet`对象的游标能够向前和向后移动。第二个值，`ResultSet.CONCUR_UPDATABLE`，如果要向`ResultSet`对象插入行，则需要它；它指定它可以被更新。
- en: The same stipulations for using strings in getter methods also apply to updater
    methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在getter方法中使用字符串的相同规定也适用于updater方法。
- en: The method `ResultSet.moveToInsertRow` moves the cursor to the insert row. The
    insert row is a special row associated with an updatable result set. It is essentially
    a buffer where a new row can be constructed by calling the updater methods prior
    to inserting the row into the result set. For example, this method calls the method
    `ResultSet.updateString` to update the insert row's `COF_NAME` column to `Kona`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`ResultSet.moveToInsertRow`将游标移动到插入行。插入行是与可更新结果集关联的特殊行。它本质上是一个缓冲区，可以通过调用更新器方法构造新行，然后将该行插入结果集。例如，此方法调用`ResultSet.updateString`方法将插入行的`COF_NAME`列更新为`Kona`。
- en: The method `ResultSet.insertRow` inserts the contents of the insert row into
    the `ResultSet` object and into the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`ResultSet.insertRow`将插入行的内容插入`ResultSet`对象和数据库中。
- en: '**Note**: After inserting a row with the `ResultSet.insertRow`, you should
    move the cursor to a row other than the insert row. For example, this example
    moves it to before the first row in the result set with the method `ResultSet.beforeFirst`.
    Unexpected results can occur if another part of your application uses the same
    result set and the cursor is still pointing to the insert row.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：使用`ResultSet.insertRow`插入一行后，应将游标移动到插入行之外的行。例如，此示例使用`ResultSet.beforeFirst`方法将其移动到结果集中的第一行之前。如果应用程序的另一部分使用相同的结果集且游标仍指向插入行，则可能会出现意外结果。'
