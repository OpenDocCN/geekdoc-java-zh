# 未检查异常  争议

> 原文：[`docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html`](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html)

因为 Java 编程语言不要求方法捕获或指定未检查异常（`RuntimeException`，`Error`及其子类），程序员可能会倾向于编写仅抛出未检查异常的代码，或者使所有异常子类继承自`RuntimeException`。这两种捷径使程序员能够编写代码，而不必理会编译器错误，也不必指定或捕获任何异常。尽管这对程序员来说可能很方便，但它绕过了`catch`或`specify`要求的意图，可能会给使用您的类的其他人造成问题。

设计者为什么决定强制一种方法来指定在其范围内可能抛出的所有未捕获的已检查异常？方法可能抛出的任何`Exception`都是方法的公共编程接口的一部分。调用方法的人必须了解方法可能抛出的异常，以便他们可以决定如何处理这些异常。这些异常与方法的编程接口一样重要，就像它的参数和`return`值一样。

下一个问题可能是：“如果记录方法的 API，包括它可能抛出的异常是如此重要，为什么不也指定运行时异常呢？”运行时异常代表的是由编程问题导致的问题，因此，API 客户端代码不能合理地预期从中恢复或以任何方式处理它们。这些问题包括算术异常，例如除以零；指针异常，例如尝试通过空引用访问对象；以及索引异常，例如尝试通过太大或太小的索引访问数组元素。

运行时异常可能在程序的任何地方发生，在典型情况下可能非常多。在每个方法声明中添加运行时异常会降低程序的清晰度。因此，编译器不要求您捕获或指定运行时异常（尽管您可以）。

一个常见的情况是抛出`RuntimeException`的情况是当用户错误调用方法时。例如，一个方法可以检查其参数是否不正确为`null`。如果参数为`null`，方法可能会抛出`NullPointerException`，这是一个*未检查*异常。

一般来说，不要仅仅因为不想麻烦指定方法可能抛出的异常而抛出`RuntimeException`或创建`RuntimeException`的子类。

这里是底线指导原则：如果客户端可以合理地预期从异常中恢复，那么将其作为已检查异常。如果客户端无法从异常中恢复，那么将其作为未检查异常。
