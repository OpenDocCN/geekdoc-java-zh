# API 设计

> 原文：[`docs.oracle.com/javase/tutorial/collections/interoperability/api-design.html`](https://docs.oracle.com/javase/tutorial/collections/interoperability/api-design.html)

在这个简短但重要的部分，你将学到一些简单的准则，让你的 API 能够与遵循这些准则的所有其他 API 无缝交互。实质上，这些规则定义了在集合世界中成为一个好“公民”所需的条件。

## 参数

如果你的 API 包含一个需要在输入时传入集合的方法，那么声明相关参数类型为集合接口类型至关重要。**永远**不要使用实现类型，因为这违背了基于接口的集合框架的目的，即允许集合在不考虑实现细节的情况下进行操作。

此外，你应该始终使用最不具体的类型。例如，如果`Collection`足够了，就不要要求一个`List`或者一个`Set`。并不是说你在输入时永远不应该要求一个`List`或者`Set`；如果一个方法依赖于这些接口的属性，那么这样做是正确的。例如，Java 平台提供的许多算法在输入时需要一个`List`，因为它们依赖于列表是有序的这一事实。然而，作为一般规则，最好在输入时使用最通用的类型：`Collection`和`Map`。

* * *

**注意：** 永远不要定义自己的临时`collection`类，并要求在输入时使用这些类的对象。这样做会使你失去 Java 集合框架提供的所有好处。

* * *

## 返回值

对于返回值，你可以比输入参数更加灵活。可以返回任何实现或扩展集合接口之一的类型的对象。这可以是接口之一，也可以是扩展或实现这些接口的特殊用途类型。

例如，可以想象一个图像处理包，称为`ImageList`，它返回实现`List`的新类的对象。除了`List`操作外，`ImageList`还可以支持任何看起来有用的特定应用操作。例如，它可能提供一个`indexImage`操作，返回一个包含`ImageList`中每个图形缩略图的图像。需要注意的是，即使 API 在输出时提供`ImageList`实例，它也应该接受任意的`Collection`（或者也许是`List`）实例作为输入。

从某种意义上说，返回值应该具有与输入参数相反的行为：最好返回最具体的适用集合接口，而不是最一般的。例如，如果你确定总是返回一个`SortedMap`，你应该给相关方法返回类型为`SortedMap`，而不是`Map`。`SortedMap` 实例比普通的`Map`实例更耗时构建，也更强大。考虑到你的模块已经投入了时间来构建`SortedMap`，让用户访问其增强功能是明智的。此外，用户将能够将返回的对象传递给需要`SortedMap`的方法，以及接受任何`Map`的方法。

## 传统 API

目前有很多 API 定义了自己的临时集合类型。虽然这很不幸，但考虑到 Java 平台的前两个主要版本中没有集合框架，这是现实。假设你拥有其中一个这样的 API；以下是你可以采取的措施。

如果可能的话，更新你的传统集合类型以实现标准集合接口之一。然后，你返回的所有集合将与其他基于集合的 API 无缝地进行交互。如果这是不可能的（例如，因为一个或多个现有类型签名与标准集合接口冲突），定义一个*适配器类*，包装你的传统集合对象之一，使其能够作为标准集合运行。（`Adapter` 类是*自定义实现*的一个示例。）

如果可能的话，通过新的调用来更新你的 API，遵循输入指南以接受标准集合接口的对象。这样的调用可以与接受传统集合类型的调用共存。如果这是不可能的，为你的传统类型提供一个构造函数或静态工厂，接受一个标准接口的对象，并返回包含相同元素（或映射）的传统集合。这两种方法中的任何一种都将允许用户将任意集合传递给你的 API。
