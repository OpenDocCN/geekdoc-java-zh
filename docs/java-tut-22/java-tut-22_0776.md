# 将 DOM 写出为 XML 文件

> 原文：[`docs.oracle.com/javase/tutorial/jaxp/xslt/writingDom.html`](https://docs.oracle.com/javase/tutorial/jaxp/xslt/writingDom.html)

在构建了一个 DOM（通过解析 XML 文件或以编程方式构建）之后，您经常希望将其保存为 XML。本节将向您展示如何使用 Xalan 转换包来实现这一点。

使用该包，您将创建一个转换器对象，将`DOMSource`连接到`StreamResult`。然后，您将调用转换器的`transform()`方法将 DOM 写出为 XML 数据。

## 读取 XML

第一步是通过解析 XML 文件在内存中创建一个 DOM。到目前为止，您应该已经对这个过程感到熟悉了。

* * *

**注意：**

本节讨论的代码位于文件`TransformationApp01.java`中。下载 XSLT 示例并将其解压缩到*install-dir*`/jaxp-1_4_2-`*release-date*`/samples`目录中。

* * *

以下代码提供了一个基本的模板供参考。基本上，这与文档对象模型课程开头使用的代码相同。

```java
import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.DocumentBuilderFactory; 
import javax.xml.parsers.FactoryConfigurationError; 
import javax.xml.parsers.ParserConfigurationException; 
import org.xml.sax.SAXException; 
import org.xml.sax.SAXParseException; 

import org.w3c.dom.Document;
import org.w3c.dom.DOMException;

import java.io.*;

public class TransformationApp01 {

    static Document document; 

    public static void main(String argv[]) {
        if (argv.length != 1) {
            System.err.println("Usage: java TransformationApp01 filename");
            System.exit (1);
        }

        DocumentBuilderFactory factory =
        DocumentBuilderFactory.newInstance();

        try {
            File f = new File(argv[0]);
            DocumentBuilder builder =
            factory.newDocumentBuilder();
            document = builder.parse(f);

        } 
        catch (SAXParseException spe) {
            // Error generated by the parser
            System.out.println("\n** Parsing error"
                               + ", line " + spe.getLineNumber()
                               + ", uri " + spe.getSystemId());
            System.out.println("  " + spe.getMessage() );

            // Use the contained exception, if any
            Exception x = spe;
            if (spe.getException() != null)
                x = spe.getException();
            x.printStackTrace();
        }
        catch (SAXException sxe) {
            // Error generated by this application
            // (or a parser-initialization error)
            Exception x = sxe;
            if (sxe.getException() != null)
                x = sxe.getException();
            x.printStackTrace();
        }
        catch (ParserConfigurationException pce) {
            // Parser with specified options 
            // cannot be built
            pce.printStackTrace();
        }
        catch (IOException ioe) {
            // I/O error
            ioe.printStackTrace();
        }
    }
}

```

## 创建一个转换器

下一步是创建一个转换器，您可以使用它将 XML 传输到`System.out`。首先，需要以下导入语句。

```java
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.dom.DOMSource; 
import javax.xml.transform.stream.StreamResult;
import java.io.*;

```

在这里，您添加了一系列类，这些类现在应该形成一个标准模式：一个实体（`Transformer`）、用于创建它的工厂（`TransformerFactory`）以及每个类可能生成的异常。因为转换始终有一个源和一个结果，所以您导入了使用 DOM 作为源（`DOMSource`）和用于结果的输出流（`StreamResult`）所需的类。

接下来，添加执行转换的代码：

```java
try {
    File f = new File(argv[0]);
    DocumentBuilder builder = factory.newDocumentBuilder();
    document = builder.parse(f);

    // Use a Transformer for output
    TransformerFactory tFactory =
    TransformerFactory.newInstance();
    Transformer transformer = 
    tFactory.newTransformer();

    DOMSource source = new DOMSource(document);
    StreamResult result = new StreamResult(System.out);
    transformer.transform(source, result);
}

```

在这里，您创建一个转换器对象，使用 DOM 构造一个源对象，并使用`System.out`构造一个结果对象。然后告诉转换器操作源对象并输出到结果对象。

在这种情况下，“转换器”实际上并没有改变任何内容。在 XSLT 术语中，您使用的是身份转换，这意味着“转换”生成源的副本，未更改。

* * *

**注意：**

您可以为转换器对象指定各种输出属性，如 W3C 规范中定义的[`www.w3.org/TR/xslt#output`](http://www.w3.org/TR/xslt#output)。例如，要获得缩进输出，可以调用以下方法：

```java
% transformer.setOutputProperty(OutputKeys.INDENT, "yes");

```

* * *

最后，以下突出显示的代码捕获可能生成的新错误：

```java
} 
catch (TransformerConfigurationException tce) {
    System.out.println("* Transformer Factory error");
    System.out.println(" " + tce.getMessage());

    Throwable x = tce;
    if (tce.getException() != null)
        x = tce.getException();
    x.printStackTrace(); 
} 
catch (TransformerException te) {
    System.out.println("* Transformation error");
    System.out.println(" " + te.getMessage());

    Throwable x = te;
    if (te.getException() != null)
        x = te.getException();
    x.printStackTrace();
} 
catch (SAXParseException spe) {
    // ...
}

```

**注意**

+   转换器对象会抛出`TransformerExceptions`。

+   工厂会抛出`TransformerConfigurationExceptions`。

+   要保留 XML 文档的`DOCTYPE`设置，还需要添加以下代码：

    ```java
    import javax.xml.transform.OutputKeys;
    ...
    if (document.getDoctype() != null) {
        String systemValue = (new File (document.getDoctype().getSystemId())).getName();
        transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemValue);
    }

    ```

要了解更多关于配置工厂和处理验证错误的信息，请参阅将 XML 数据读入 DOM。

### 运行`TransformationApp01`示例

1.  **导航到`samples`目录。**

    ```java
    % cd *install-dir*/jaxp-1_4_2-*release-date*/samples.

    ```

1.  **点击此链接下载 XSLT 示例并将其解压缩到*install-dir*`/jaxp-1_4_2-`*release-date*`/samples`目录中。**

1.  **导航到`xslt`目录。**

    ```java
    % cd xslt

    ```

1.  **编译`TransformationApp01`示例。**

    输入以下命令：

    ```java
    % javac TransformationApp01.java

    ```

1.  **在 XML 文件上运行`TransformationApp01`示例。**

    在下面的情况下，在解压示例包后，`TransformationApp01`在`xslt/data`目录中的`foo.xml`文件上运行。

    ```java
    % java TransformationApp01 data/foo.xml

    ```

    你将看到以下输出：

    ```java
    <?xml version="1.0" 
        encoding="UTF-8" 
        standalone="no"?><doc>
      <name first="David" last="Marston"/>
      <name first="David" last="Bertoni"/>
      <name first="Donald" last="Leslie"/>
      <name first="Emily" last="Farmer"/>
      <name first="Joseph" last="Kesselman"/>
      <name first="Myriam" last="Midy"/>
      <name first="Paul" last="Dick"/>
      <name first="Stephen" last="Auriemma"/>
      <name first="Scott" last="Boag"/>
      <name first="Shane" last="Curcuru"/>

    ```

    如创建转换器中所述，这个转换器实际上并没有改变任何内容，而只是执行了恒等变换，生成了源的副本。真正的转换将在从任意数据结构生成 XML 中执行。

## 写出 DOM 的子树

也可以操作 DOM 的子树。在本节中，你将尝试这个选项。

* * *

**注意：**

本节讨论的代码在 TranformationApp02.java 中。如果你还没有这样做，下载 XSLT 示例并将其解压缩到*install-dir*`/jaxp-1_4_2-`*release-date*`/samples`目录中。

* * *

过程中唯一的区别是现在将使用 DOM 中的一个节点创建`DOMSource`，而不是整个 DOM。第一步是导入你需要获取的节点的类，如下面突出显示的代码所示：

```java
import org.w3c.dom.Document;
import org.w3c.dom.DOMException;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList; 

```

下一步是找到一个好的节点进行实验。以下突出显示的代码选择第一个`<name>`元素。

```java
try {
    File f = new File(argv[0]);
    DocumentBuilder builder = factory.newDocumentBuilder();
    document = builder.parse(f);

    NodeList list = document.getElementsByTagName("name");
    Node node = list.item(0); 
}

```

在创建转换器中，源对象是通过以下代码行从整个文档构造的

```java
DOMSource source = new DOMSource(document);

```

然而，下面突出显示的代码行构造了一个由特定节点为根的子树组成的源对象。

```java
DOMSource source = new DOMSource(node);
StreamResult result = new StreamResult(System.out);
transformer.transform(source, result);

```

### 运行`TranformationApp02`示例

1.  **导航到`samples`目录。**

    ```java
    % cd *install-dir*/jaxp-1_4_2-*release-date*/samples.

    ```

1.  **点击此链接下载 XSLT 示例并将其解压缩到*install-dir*`/jaxp-1_4_2-`*release-date*`/samples`目录中。**

1.  **导航到`xslt`目录。**

    ```java
    cd xslt

    ```

1.  **编译`TranformationApp02`示例。**

    输入以下命令：

    ```java
    % javac xslt/TranformationApp02.java

    ```

1.  **在 XML 文件上运行`TranformationApp02`示例。**

    在下面的情况下，在解压示例包后，`TranformationApp02`在`xslt/data`目录中的`foo.xml`文件上运行。

    ```java
    % java TranformationApp02 data/foo.xml

    ```

    你将看到以下输出：

    ```java
    <?xml version="1.0" encoding="UTF-8" 
        standalone="no"?><doc><name 
        first="David" last="Marston"/>

    ```

    这次，只打印出了第一个`<name>`元素。

    到目前为止，你已经看到如何使用转换器写出 DOM，以及如何使用 DOM 的子树作为转换中的源对象。在下一节中，你将看到如何使用转换器从你能够解析的任何数据结构创建 XML。
