# 课程：用于安全代码和文件交换的 API 和工具使用

> 原文：[`docs.oracle.com/javase/tutorial/security/sigcert/index.html`](https://docs.oracle.com/javase/tutorial/security/sigcert/index.html)

本课程解释了为什么需要数字签名、证书和密钥库。该课程还比较了使用这些工具与 JDK 安全 API 生成签名的情况。这些工具的使用在接下来的两节课中进行演示，签署代码并授予权限 和 文件交换。API 的使用在 生成和验证签名 课程中进行演示。

本课程包含以下部分

+   代码和文档安全

+   工具和 API 注释

+   使用 JDK 安全 API 签署文档

+   使用工具签署代码或文档

## 代码和文档安全

如果您通过电子方式向某人发送重要文件（或文件）、或要运行的小程序或应用程序，接收方需要一种方法来验证文件或代码是否来自您，并且在传输过程中未被修改（例如，被恶意用户拦截）。数字签名、证书和密钥库都有助于确保您发送的文件的安全性。

### 数字签名

使用数字签名的基本思想如下。

1.  您使用您可以通过`keytool`或安全 API 方法生成的**私钥**对文档或代码进行“签名”。也就是说，您使用`jarsigner`工具或安全 API 方法为文档或代码生成数字签名。

1.  您将签名的文档发送给接收方。

1.  您还向接收方提供您的**公钥**。这个公钥对应于您最初用于生成签名的私钥。

1.  接收方使用您的公钥来验证您的文件是否来自您，并且在到达之前未被修改。

接收方需要确保您的公钥*本身*是真实的，然后才能使用它来验证您的签名是否真实。因此，您通常会提供一个包含您的公钥以及可以为您的密钥真实性作证的**证书颁发机构**的密钥的**证书**。有关详细信息，请参见下一节。

有关签名和验证术语和概念的更多信息，以及有关好处的进一步解释，请参见“JAR 文件打包程序”课程的 签署 JAR 文件 部分。

### 证书

证书包含：

+   一个公钥。

+   证书的“显著名称”信息是指证书的实体（个人、公司等）的信息。这个实体被称为证书*主体*或*所有者*。显著名称信息包括以下属性（或其子集）：实体的名称、组织单位、组织、城市或地点、州或省和国家代码。

+   数字签名。证书由一个实体，*颁发者*，签名，以证明封闭的公钥是另一个实体，*所有者*的实际公钥。

+   签名者（颁发者）的显著名称信息。

收件人检查证书是否有效的一种方法是使用颁发者（签名者）的公钥验证其数字签名。该密钥本身可以存储在另一个证书中，该证书的签名也可以通过使用下一个证书的颁发者的公钥进行验证，而该密钥可能*也*存储在另*一个*证书中，依此类推。当你到达一个你已经信任的公钥并用它来验证相应证书上的签名时，你可以停止检查。

如果收件人无法建立信任链，那么他/她可以使用 `keytool` 的 `-import` 或 `-printcert` 命令计算证书的**指纹**。指纹是一个相对较短的数字，可以唯一且可靠地识别证书。（从技术上讲，指纹是证书信息的哈希值，使用消息摘要函数。）然后，收件人可以打电话给证书所有者，并将收到的证书的指纹值与发送的证书进行比较。如果指纹相同，则证书相同。

因此，你可以确保证书在传输过程中没有被修改。在处理证书时的另一个潜在不确定性是发送者的身份。有时证书是**自签名**的，即使用与证书中的公钥对应的私钥签名；颁发者与主体相同。

自签名证书对于开发和测试应用程序很有用。然而，在部署给用户之前，从一个受信任的第三方（称为认证机构（CA））那里获取证书是必要的。为此，你向 CA 发送一个自签名证书签名请求（CSR）。CA 验证 CSR 上的签名和你的身份，可能通过检查你的驾驶执照或其他信息。然后，CA 通过使用自己的（CA 的）私钥签发证书并为你作为公钥所有者背书。任何信任颁发 CA 的公钥的人现在都可以验证证书上的签名。在许多情况下，颁发 CA 本身可能有一个来自 CA 层次结构更高层的证书，导致**证书链**。

你信任的实体的证书通常被导入到你的密钥库中作为“**受信任的证书**”。每个这样的证书中的公钥可以用来验证使用相应私钥生成的签名。这样的验证可以通过以下方式完成：

+   `jarsigner` 工具（如果文档/代码和签名出现在一个 JAR 文件中），

+   API 方法，或

+   运行时系统，在尝试访问资源时，如果策略文件指定允许代码尝试访问的资源访问，且其签名是真实的，则允许访问。代码的类文件和签名必须在一个 JAR 文件中。

如果您要向他人发送签名的代码或文档，则需要向他们提供包含与用于签署代码/文档的私钥对应的公钥的证书。`keytool` 的 `-export` 命令或 API 方法可以将您的证书从密钥库导出到文件中，然后可以将该文件发送给需要的任何人。接收证书的人可以将其导入到密钥库中作为受信任的证书，例如使用 API 方法或 `keytool` 的 `-import` 命令。

如果您使用 `jarsigner` 工具为 JAR 文件生成签名，则该工具会从您的密钥库中检索您的证书及其支持的证书链。然后，该工具将它们与签名一起存储在 JAR 文件中。

### 密钥库

私钥及其相关的公钥证书存储在受密码保护的数据库中，称为**密钥库**。密钥库可以包含两种类型的条目：上述讨论的受信任证书条目，以及密钥/证书条目，每个条目包含一个私钥和相应的公钥证书。密钥库中的每个条目都由一个*别名*标识。

密钥库所有者可以在密钥库中拥有多个密钥，通过不同的别名访问。别名通常以密钥库所有者在其中使用相关密钥的特定角色命名。别名也可以标识密钥的用途。例如，别名 `signPersonalEmail` 可能用于标识一个用于签署个人电子邮件的密钥库条目，而别名 `signJarFiles` 可能用于标识一个用于签署 JAR 文件的条目。

`keytool` 工具可用于

+   创建私钥及其相关的公钥证书

+   发出证书请求，然后将其发送给适当的认证机构

+   导入从您联系的认证机构获得的证书回复

+   导入属于其他方的公钥证书作为受信任的证书

+   管理您的密钥库

API 方法也可用于访问和修改密钥库。

## 工具和 API 注意事项

请注意以下与数字签名相关的工具和 API 使用。

+   您可以使用 JDK 安全 API、工具或组合来生成密钥和签名，并导入证书。您可以使用这些 API 或工具功能与他人安全地交换文档。

+   要使用*工具*进行文档交换，文档必须放在 JAR（Java ARchive）文件中，可以通过`jar`工具创建。JAR 文件是将多个文件封装在一个位置的好方法。当文件被“签名”时，生成的数字签名字节需要存储在某个地方。当 JAR 文件被签名时，签名可以放在 JAR 文件本身中。这就是当您使用`jarsigner`工具对 JAR 文件进行签名时发生的情况。

+   如果您正在创建将要签署的小程序代码，它需要放在 JAR 文件中。如果您正在创建可能受到安全管理器限制的应用程序代码，同样需要放在 JAR 文件中。您需要 JAR 文件的原因是，当策略文件指定由特定实体签名的代码允许一个或多个操作，例如特定文件读取或写入时，预期代码来自已签名的 JAR 文件。（术语“已签名代码”是指“出现在已签名 JAR 文件中的类文件中的代码”的简称。）

+   为了使运行时系统检查代码签名，将运行代码的人/组织首先需要将验证用于签署代码的私钥对应的公钥的证书导入其密钥库中。

+   为了使`jarsigner`工具验证 JAR 文件签名的真实性，首先需要将接收到的 JAR 文件的人/组织导入其密钥库中，以验证与用于签署代码的私钥对应的公钥的证书。

+   目前还没有用于证书创建的 API。

## 使用 JDK 安全 API 签署文档

生成和验证签名展示了如何使用 JDK 安全 API 签署文档。该课程展示了由拥有原始文档的人执行的一个程序会做什么

+   生成密钥，

+   使用私钥为数据生成数字签名，然后

+   导出公钥和签名到文件。

然后展示了另一个程序的示例，由数据、签名和公钥的接收者执行。展示了该程序如何

+   导入公钥

+   验证签名的真实性。

本课程还展示了导入和提供密钥的替代方法，包括证书。

## 使用工具签署代码或文档

签署代码并授予权限课程展示了如何使用 Java 安全工具将您的代码放入 JAR 文件中，对其进行签名，并导出您的公钥。然后展示了您的接收方如何使用相同的 Java 工具导入您的公钥证书，然后向策略文件添加条目，以授予您的代码访问受接收方控制的系统资源所需的权限。

文件交换课程教你如何使用 Java 安全工具签署文档，然后使用`keytool`导出公钥证书，对应于使用`keytool`签署该文档的私钥。然后它展示了如何接收者可以通过安装您的公钥证书并使用`jarsigner`工具验证您的签名。

这两个课程有很多共同之处。在两种情况下，发送代码或文档的前两个步骤是：

+   使用`jar`工具创建包含文档或类文件的 JAR 文件。

+   生成密钥（如果尚不存在），使用`keytool`的`-genkey`命令。

接下来的两个步骤是可选的：

+   使用`keytool`的`-certreq`命令；然后将生成的证书签名请求发送给认证机构（CA），如 VeriSign。

+   使用`keytool`的`-import`命令导入 CA 的响应。

接下来的两个步骤是必需的：

+   使用之前生成的私钥，使用`jarsigner`工具对 JAR 文件进行签名。

+   使用`keytool`的`-export`命令导出公钥证书。然后将签名的 JAR 文件和证书提供给接收者。

在两种情况下，签署的 JAR 文件和证书的接收者应该使用`keytool`的`-import`命令将证书导入为受信任的证书。`keytool`将尝试从要导入的证书到密钥库中已受信任的证书构建信任链。如果失败，`keytool`将显示证书指纹并提示您进行验证。

如果发送的是代码，则接收者还需要修改策略文件以允许由导入证书中的公钥对应的私钥签名的代码访问所需资源。可以使用**策略工具**来执行此操作。

如果发送的是一个或多个文档，则接收者需要使用`jarsigner`工具验证 JAR 文件签名的真实性。

本课程讨论了两个可选步骤。其他步骤在接下来的两个课程中涵盖，签署代码并授予权限和文件交换。

### 为公钥证书生成证书签名请求（CSR）

当使用`keytool`生成公私钥对时，它会创建一个包含私钥和公钥的自签名证书的密钥库条目。（即，证书使用相应的私钥进行签名。）这在开发和测试应用程序时是足够的。

然而，如果证书由认证机构（CA）签名，其他人更有可能信任该证书。要获得由 CA 签名的证书，首先需要生成证书签名请求（CSR），通过类似以下命令：

```java
keytool -certreq -alias *alias* -file *csrFile* 

```

这里*alias*用于访问包含私钥和公钥证书的密钥库条目，*csrFile*指定此命令创建的 CSR 使用的名称。

然后，你将此文件提交给 CA，如 VeriSign, Inc.。CA 对你（请求者/"主体"）进行验证，然后签署并返回一个验证你的公钥的证书。通过签署证书，CA 保证你是公钥的所有者。

在某些情况下，CA 会返回一系列证书，每个证书都用于验证链中前一个证书签发者的公钥。

### 导入来自 CA 的响应

在向认证机构（CA）提交证书签名请求（CSR）后，你需要通过导入 CA 返回给你的证书（或证书链）来用证书链替换密钥库中的原始自签名证书。

但首先，你需要在你的密钥库中（或下面描述的`cacerts`密钥库文件中）有一个"受信任证书"条目，用于验证*CA*的公钥。有了这样的条目，可以验证 CA 对证书的签名。也就是说，可以验证 CA 对证书的签名，或者验证 CA 发送给你作为 CSR 响应中的最终证书链上的最终证书的签名。

### 从 CA 导入证书作为"受信任证书"

在导入来自 CA 的证书回复之前，你需要在你的密钥库或`cacerts`文件中拥有一个或多个"受信任证书"。

+   如果证书回复是一个证书链，你只需要链中的顶层证书 -- "根" CA 证书，用于验证该 CA 的公钥。

+   如果证书回复是单个证书，你需要签发它的 CA 的证书。如果该证书不是自签名的，你需要其签发者的证书，依此类推，直到自签名的"根" CA 证书。

`cacerts`文件代表一个系统范围的带有 CA 证书的密钥库。该文件位于 JRE 安全属性目录`*java.home*/lib/security`中，其中*java.home*是 JRE 安装目录。

* * *

**重要提示：验证你的`cacerts`文件**

由于你信任`cacerts`文件中的 CA 作为签署和颁发证书给其他实体的实体，你必须仔细管理`cacerts`文件。`cacerts`文件应只包含你信任的 CA 的证书。你有责任验证`cacerts`文件中捆绑的受信任根 CA 证书，并做出自己的信任决定。要从`cacerts`文件中删除一个不受信任的 CA 证书，使用`keytool`命令的删除选项。你可以在 JRE 安装目录中找到`cacerts`文件。如果没有权限编辑此文件，请联系系统管理员。

* * *

`cacerts`文件包含许多受信任的 CA 证书。如果您将您的 CSR 发送给了这些受信任的供应商之一（比如 VeriSign），您就不需要将供应商的根证书作为受信任证书导入到您的密钥库中；您可以继续到下一个部分，查看如何从 CA 导入证书回复。

从 CA 获得的证书通常是自签名的或者由另一个 CA 签名的，此时您还需要一个证书来验证该 CA 的公钥。假设 ABC 公司是一个 CA，并且您获得了一个名为`ABCCA.cer`的文件，据称是来自 ABC 公司的自签名证书，用于验证该 CA 的公钥。

在将证书导入为“受信任”证书之前，请务必确保证书是有效的！首先查看它（使用`keytool`的`-printcert`命令或者`keytool`的`-import`命令，不带`-noprompt`选项），并确保显示的证书指纹与预期的一致。您可以联系发送证书的人，并将您看到的指纹与他们展示的或者安全的公钥存储库展示的指纹进行比较。只有当指纹相等时，才能保证证书在传输过程中没有被替换为其他人（例如，攻击者）的证书。如果发生这样的攻击，并且您在导入证书之前没有检查证书，那么您将信任攻击者签署的任何内容。

如果您相信该证书是有效的，您可以通过类似以下命令将其添加到您的密钥库中：

```java
keytool -import -alias *alias* -file ABCCA.cer -keystore *storefile* 

```

此命令在密钥库中创建一个名为*storefile*指定的“受信任证书”条目。该条目包含来自文件`ABCCA.cer`的数据，并分配指定的别名。

### 从 CA 导入证书回复

一旦您已经导入了所需的受信任证书，就像前一节中描述的那样，或者它们已经存在于您的密钥库中或者在`cacerts`文件中，您可以导入证书回复，从而用证书链替换您的自签名证书。这个链将是 CA 对您的请求的回复中返回的（如果 CA 的回复是一个链）或者通过使用证书回复和已经在密钥库中或者`cacerts`密钥库文件中可用的受信任证书构建的（如果 CA 的回复是一个单一证书）。

举例来说，假设您将您的证书签名请求发送给了 VeriSign。然后您可以通过以下方式导入回复，假设返回的证书在*certReplyFile*指定的文件中：

```java
keytool -import -trustcacerts
    -keystore *storefile*
    -alias *alias* 
    -file *certReplyFile* 

```

在一行上输入此命令。

证书回复通过使用密钥库中的受信任证书进行验证，并可选择使用`cacerts`密钥库文件中配置的证书进行验证（如果指定了`-trustcacerts`选项）。每个链中的证书都会被验证，使用链中下一级别的证书。您只需要信任链中顶级的“根”CA 证书。如果您尚未信任顶级证书，`keytool`将显示该证书的指纹，并询问您是否要信任它。

指定（通过*别名*）条目的新证书链将替换与该条目关联的旧证书（或链）。只有在提供有效的*keypass*，用于保护条目私钥的密码时，才能替换旧链。如果未提供密码，并且私钥密码与密钥库密码不同，则会提示用户输入。

关于生成证书签名请求（CSR）和导入证书回复的更详细信息，请参阅`keytool`文档：

+   [带有 Windows 示例的 keytool 文档](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/keytool.html)

+   [带有 UNIX 示例的 keytool 文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html)
