+   [Effective Java 中文第三版](README.md)
+   [1. 考虑使用静态工厂方法替代构造方法](01.md)
+   [2. 当构造方法参数过多时使用 builder 模式](02.md)
+   [3. 使用私有构造方法或枚类实现 Singleton 属性](03.md)
+   [4. 使用私有构造器执行非实例化](04.md)
+   [5.  依赖注入优于硬连接资源（hardwiring resources）](05.md)
+   [6. 避免创建不必要的对象](06.md)
+   [7. 消除过期的对象引用](07.md)
+   [8. 避免使用 Finalizer 和 Cleaner 机制](08.md)
+   [9. 使用 try-with-resources 语句替代 try-finally 语句](09.md)
+   [10. 重写 equals 方法时遵守通用约定](10.md)
+   [11. 重写 equals 方法时同时也要重写 hashcode 方法](11.md)
+   [12. 始终重写 toString 方法](12.md)
+   [13. 谨慎地重写 clone 方法](13.md)
+   [14. 考虑实现 Comparable 接口](14.md)
+   [15. 使类和成员的可访问性最小化](15.md)
+   [16. 在公共类中使用访问方法而不是公共属性](16.md)
+   [17. 最小化可变性](17.md)
+   [18. 组合优于继承](18.md)
+   [19.  要么设计继承并提供文档说明，要么禁用继承](19.md)
+   [20. 接口优于抽象类](20.md)
+   [21. 为后代设计接口](21.md)
+   [22. 接口仅用来定义类型](22.md)
+   [23. 类层次结构优于标签类](23.md)
+   [24. 支持使用静态成员类而不是非静态类](24.md)
+   [25. 将源文件限制为单个顶级类](25.md)
+   [26. 不要使用原始类型](26.md)
+   [27. 消除非检查警告](27.md)
+   [28. 列表优于数组](28.md)
+   [29. 优先考虑泛型](29.md)
+   [30. 优先使用泛型方法](30.md)
+   [31. 使用限定通配符来增加 API 的灵活性](31.md)
+   [32. 合理地结合泛型和可变参数](32.md)
+   [33. 优先考虑类型安全的异构容器](33.md)
+   [34. 使用枚举类型替代整型常量](34.md)
+   [35. 使用实例属性替代序数](35.md)
+   [36. 使用 EnumSet 替代位属性](36.md)
+   [37. 使用 EnumMap 替代序数索引](37.md)
+   [38. 使用接口模拟可扩展的枚举](38.md)
+   [39. 注解优于命名模式](39.md)
+   [40. 始终使用 Override 注解](40.md)
+   [41. 使用标记接口定义类型](41.md)
+   [42. lambda 表达式优于匿名类](42.md)
+   [43. 方法引用优于 lambda 表达式](43.md)
+   [44. 优先使用标准的函数式接口](44.md)
+   [45. 明智审慎地使用 Stream](45.md)
+   [46. 优先考虑流中无副作用的函数](46.md)
+   [47. 优先使用 Collection 而不是 Stream 来作为方法的返回类型](47.md)
+   [48. 谨慎使用流并行](48.md)
+   [49. 检查参数有效性](49.md)
+   [50. 必要时进行防御性拷贝](50.md)
+   [51. 仔细设计方法签名](51.md)
+   [52. 明智审慎地使用重载](52.md)
+   [53. 明智审慎地使用可变参数](53.md)
+   [54. 返回空的数组或集合，不要返回 null](54.md)
+   [55. 明智审慎地返回 Optional](55.md)
+   [56. 为所有已公开的 API 元素编写文档注释](56.md)
+   [57. 最小化局部变量的作用域](57.md)
+   [58. for-each 循环优于传统 for 循环](58.md)
+   [59. 了解并使用库](59.md)
+   [60. 若需要精确答案就应避免使用 float 和 double 类型](60.md)
+   [61. 基本数据类型优于包装类](61.md)
+   [62. 当使用其他类型更合适时应避免使用字符串](62.md)
+   [63. 当心字符串连接引起的性能问题](63.md)
+   [64. 通过接口引用对象](64.md)
+   [65. 接口优于反射](65.md)
+   [66. 明智审慎地本地方法](66.md)
+   [67. 明智审慎地进行优化](67.md)
+   [68. 遵守被广泛认可的命名约定](68.md)
+   [69. 只针对异常的情况下才使用异常](69.md)
+   [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常](70.md)
+   [71. 避免不必要的使用受检异常](71.md)
+   [72. 优先使用标准的异常](72.md)
+   [73. 抛出与抽象对应的异常](73.md)
+   [74. 每个方法抛出的异常都需要创建文档](74.md)
+   [75. 在细节消息中包含失败一捕获信息](75.md)
+   [76. 保持失败原子性](76.md)
+   [77. 不要忽略异常](77.md)
+   [78. 同步访问共享的可变数据](78.md)
+   [79. 避免过度同步](79.md)
+   [80. executor 、task 和 stream 优先于线程](80.md)
+   [81. 并发工具优于 wait 和 notify](81.md)
+   [82. 文档应包含线程安全属性](82.md)
+   [83. 明智审慎的使用延迟初始化](83.md)
+   [84. 不要依赖线程调度器](84.md)
+   [85. 优先选择 Java 序列化的替代方案](85.md)
+   [86. 非常谨慎地实现 Serializable](86.md)
+   [87. 考虑使用自定义的序列化形式](87.md)
+   [88. 保护性的编写 readObject 方法](88.md)
+   [89. 对于实例控制，枚举类型优于 readResolve](89.md)
+   [90. 考虑用序列化代理代替序列化实例](90.md)
